<pre>
0.1.4
<b>FAIL</b> <b>invalid/control/comment-del</b>
<b> </b>    Expected an error, but no error was reported.

<b>     input sent to parser-cmd:</b>
       comment-del = "0x7f" # 

<b>     output from parser-cmd (stdout):</b>
       {
         "comment-del": {
           "type": "string",
           "value": "0x7f"
         }
       }

<b>     want:</b>
       Exit code 1

<b>FAIL</b> <b>invalid/integer/positive-bin</b>
<b> </b>    Expected an error, but no error was reported.

<b>     input sent to parser-cmd:</b>
       positive-bin = +0b11010110

<b>     output from parser-cmd (stdout):</b>
       {
         "positive-bin": {
           "type": "integer",
           "value": "214"
         }
       }

<b>     want:</b>
       Exit code 1

<b>FAIL</b> <b>invalid/integer/positive-hex</b>
<b> </b>    Expected an error, but no error was reported.

<b>     input sent to parser-cmd:</b>
       positive-hex = +0xff

<b>     output from parser-cmd (stdout):</b>
       {
         "positive-hex": {
           "type": "integer",
           "value": "255"
         }
       }

<b>     want:</b>
       Exit code 1

<b>FAIL</b> <b>invalid/integer/positive-oct</b>
<b> </b>    Expected an error, but no error was reported.

<b>     input sent to parser-cmd:</b>
       positive-oct = +0o755

<b>     output from parser-cmd (stdout):</b>
       {
         "positive-oct": {
           "type": "integer",
           "value": "493"
         }
       }

<b>     want:</b>
       Exit code 1

<b>FAIL</b> <b>valid/array/array</b>
<b> </b>    Error: Error { message: "invalid number at line 5 column 3" }
<b> </b>    
<b> </b>    Exit 1

<b>     input sent to parser-cmd:</b>
       ints = [1, 2, 3, ]
       floats = [1.1, 2.1, 3.1]
       strings = ["a", "b", "c"]
       dates = [
         1987-07-05T17:45:00Z,
         1979-05-27T07:32:00Z,
         2006-06-01T11:00:00Z,
       ]
       comments = [
                1,
                2, #this is ok
       ]

<b>     output from parser-cmd (stderr):</b>
       Error: Error { message: "invalid number at line 5 column 3" }
       
       Exit 1

<b>     want:</b>
          <empty>

<b>FAIL</b> <b>valid/comment/everywhere</b>
<b> </b>    Error: Error { message: "invalid number at line 27 column 6" }
<b> </b>    
<b> </b>    Exit 1

<b>     input sent to parser-cmd:</b>
       # Top comment.
         # Top comment.
       # Top comment.
       
       # [no-extraneous-groups-please]
       
       [group] # Comment
       answer = 42 # Comment
       # no-extraneous-keys-please = 999
       # Inbetween comment.
       more = [ # Comment
         # What about multiple # comments?
         # Can you handle it?
         #
                 # Evil.
       # Evil.
         42, 42, # Comments within arrays are fun.
         # What about multiple # comments?
         # Can you handle it?
         #
                 # Evil.
       # Evil.
       # ] Did I fool you?
       ] # Hopefully not.
       
       # Make sure the space between the datetime and "#" isn't lexed.
       dt = 1979-05-27T07:32:12-07:00  # c
       d = 1979-05-27 # Comment

<b>     output from parser-cmd (stderr):</b>
       Error: Error { message: "invalid number at line 27 column 6" }
       
       Exit 1

<b>     want:</b>
          <empty>

<b>FAIL</b> <b>valid/datetime/datetime</b>
<b> </b>    Error: Error { message: "invalid number at line 1 column 9" }
<b> </b>    
<b> </b>    Exit 1

<b>     input sent to parser-cmd:</b>
       space = 1987-07-05 17:45:00Z
       lower = 1987-07-05t17:45:00z

<b>     output from parser-cmd (stderr):</b>
       Error: Error { message: "invalid number at line 1 column 9" }
       
       Exit 1

<b>     want:</b>
          <empty>

<b>FAIL</b> <b>valid/datetime/local</b>
<b> </b>    Error: Error { message: "invalid number at line 1 column 9" }
<b> </b>    
<b> </b>    Exit 1

<b>     input sent to parser-cmd:</b>
       local = 1987-07-05T17:45:00
       milli = 1977-12-21T10:32:00.555
       space = 1987-07-05 17:45:00

<b>     output from parser-cmd (stderr):</b>
       Error: Error { message: "invalid number at line 1 column 9" }
       
       Exit 1

<b>     want:</b>
          <empty>

<b>FAIL</b> <b>valid/datetime/local-date</b>
<b> </b>    Error: Error { message: "invalid number at line 1 column 15" }
<b> </b>    
<b> </b>    Exit 1

<b>     input sent to parser-cmd:</b>
       bestdayever = 1987-07-05

<b>     output from parser-cmd (stderr):</b>
       Error: Error { message: "invalid number at line 1 column 15" }
       
       Exit 1

<b>     want:</b>
          <empty>

<b>FAIL</b> <b>valid/datetime/local-time</b>
<b> </b>    Error: Error { message: "expected newline, found a colon at line 1 column 18" }
<b> </b>    
<b> </b>    Exit 1

<b>     input sent to parser-cmd:</b>
       besttimeever = 17:45:00
       milliseconds = 10:32:00.555

<b>     output from parser-cmd (stderr):</b>
       Error: Error { message: "expected newline, found a colon at line 1 column 18" }
       
       Exit 1

<b>     want:</b>
          <empty>

<b>FAIL</b> <b>valid/datetime/milliseconds</b>
<b> </b>    Error: Error { message: "invalid number at line 1 column 9" }
<b> </b>    
<b> </b>    Exit 1

<b>     input sent to parser-cmd:</b>
       utc1  = 1987-07-05T17:45:56.123Z
       utc2  = 1987-07-05T17:45:56.6Z
       wita1 = 1987-07-05T17:45:56.123+08:00
       wita2 = 1987-07-05T17:45:56.6+08:00

<b>     output from parser-cmd (stderr):</b>
       Error: Error { message: "invalid number at line 1 column 9" }
       
       Exit 1

<b>     want:</b>
          <empty>

<b>FAIL</b> <b>valid/datetime/timezone</b>
<b> </b>    Error: Error { message: "invalid number at line 1 column 8" }
<b> </b>    
<b> </b>    Exit 1

<b>     input sent to parser-cmd:</b>
       utc  = 1987-07-05T17:45:56Z
       pdt  = 1987-07-05T17:45:56-05:00
       nzst = 1987-07-05T17:45:56+12:00
       nzdt = 1987-07-05T17:45:56+13:00  # DST

<b>     output from parser-cmd (stderr):</b>
       Error: Error { message: "invalid number at line 1 column 8" }
       
       Exit 1

<b>     want:</b>
          <empty>

<b>FAIL</b> <b>valid/example</b>
<b> </b>    Error: Error { message: "invalid number at line 1 column 17" }
<b> </b>    
<b> </b>    Exit 1

<b>     input sent to parser-cmd:</b>
       best-day-ever = 1987-07-05T17:45:00Z
       
       [numtheory]
       boring = false
       perfection = [6, 28, 496]

<b>     output from parser-cmd (stderr):</b>
       Error: Error { message: "invalid number at line 1 column 17" }
       
       Exit 1

<b>     want:</b>
          <empty>

<b>FAIL</b> <b>valid/spec-example-1</b>
<b> </b>    Error: Error { message: "invalid number at line 7 column 7" }
<b> </b>    
<b> </b>    Exit 1

<b>     input sent to parser-cmd:</b>
       # This is a TOML document. Boom.
       
       title = "TOML Example"
       
       [owner]
       name = "Lance Uppercut"
       dob = 1979-05-27T07:32:00-08:00 # First class dates? Why not?
       
       [database]
       server = "192.168.1.1"
       ports = [ 8001, 8001, 8002 ]
       connection_max = 5000
       enabled = true
       
       [servers]
       
         # You can indent as you please. Tabs or spaces. TOML don't care.
         [servers.alpha]
         ip = "10.0.0.1"
         dc = "eqdc10"
       
         [servers.beta]
         ip = "10.0.0.2"
         dc = "eqdc10"
       
       [clients]
       data = [ ["gamma", "delta"], [1, 2] ]
       
       # Line breaks are OK when inside arrays
       hosts = [
         "alpha",
         "omega"
       ]

<b>     output from parser-cmd (stderr):</b>
       Error: Error { message: "invalid number at line 7 column 7" }
       
       Exit 1

<b>     want:</b>
          <empty>

<b>FAIL</b> <b>valid/spec-example-1-compact</b>
<b> </b>    Error: Error { message: "invalid number at line 5 column 5" }
<b> </b>    
<b> </b>    Exit 1

<b>     input sent to parser-cmd:</b>
       #Useless spaces eliminated.
       title="TOML Example"
       [owner]
       name="Lance Uppercut"
       dob=1979-05-27T07:32:00-08:00#First class dates
       [database]
       server="192.168.1.1"
       ports=[8001,8001,8002]
       connection_max=5000
       enabled=true
       [servers]
       [servers.alpha]
       ip="10.0.0.1"
       dc="eqdc10"
       [servers.beta]
       ip="10.0.0.2"
       dc="eqdc10"
       [clients]
       data=[["gamma","delta"],[1,2]]
       hosts=[
       "alpha",
       "omega"
       ]

<b>     output from parser-cmd (stderr):</b>
       Error: Error { message: "invalid number at line 5 column 5" }
       
       Exit 1

<b>     want:</b>
          <empty>

<b>FAIL</b> <b>valid/spec/local-date-0</b>
<b> </b>    Error: Error { message: "invalid number at line 1 column 7" }
<b> </b>    
<b> </b>    Exit 1

<b>     input sent to parser-cmd:</b>
       ld1 = 1979-05-27

<b>     output from parser-cmd (stderr):</b>
       Error: Error { message: "invalid number at line 1 column 7" }
       
       Exit 1

<b>     want:</b>
          <empty>

<b>FAIL</b> <b>valid/spec/local-date-time-0</b>
<b> </b>    Error: Error { message: "invalid number at line 1 column 8" }
<b> </b>    
<b> </b>    Exit 1

<b>     input sent to parser-cmd:</b>
       ldt1 = 1979-05-27T07:32:00
       ldt2 = 1979-05-27T00:32:00.999999

<b>     output from parser-cmd (stderr):</b>
       Error: Error { message: "invalid number at line 1 column 8" }
       
       Exit 1

<b>     want:</b>
          <empty>

<b>FAIL</b> <b>valid/spec/local-time-0</b>
<b> </b>    Error: Error { message: "invalid number at line 1 column 8" }
<b> </b>    
<b> </b>    Exit 1

<b>     input sent to parser-cmd:</b>
       lt1 = 07:32:00
       lt2 = 00:32:00.999999

<b>     output from parser-cmd (stderr):</b>
       Error: Error { message: "invalid number at line 1 column 8" }
       
       Exit 1

<b>     want:</b>
          <empty>

<b>FAIL</b> <b>valid/spec/offset-date-time-0</b>
<b> </b>    Error: Error { message: "invalid number at line 1 column 8" }
<b> </b>    
<b> </b>    Exit 1

<b>     input sent to parser-cmd:</b>
       odt1 = 1979-05-27T07:32:00Z
       odt2 = 1979-05-27T00:32:00-07:00
       odt3 = 1979-05-27T00:32:00.999999-07:00

<b>     output from parser-cmd (stderr):</b>
       Error: Error { message: "invalid number at line 1 column 8" }
       
       Exit 1

<b>     want:</b>
          <empty>

<b>FAIL</b> <b>valid/spec/offset-date-time-1</b>
<b> </b>    Error: Error { message: "invalid number at line 1 column 8" }
<b> </b>    
<b> </b>    Exit 1

<b>     input sent to parser-cmd:</b>
       odt4 = 1979-05-27 07:32:00Z

<b>     output from parser-cmd (stderr):</b>
       Error: Error { message: "invalid number at line 1 column 8" }
       
       Exit 1

<b>     want:</b>
          <empty>

<b>FAIL</b> <b>valid/spec/table-7</b>
<b> </b>    Error: Error { message: "invalid number at line 8 column 16" }
<b> </b>    
<b> </b>    Exit 1

<b>     input sent to parser-cmd:</b>
       # Top-level table begins.
       name = "Fido"
       breed = "pug"
       
       # Top-level table ends.
       [owner]
       name = "Regina Dogman"
       member_since = 1999-08-04

<b>     output from parser-cmd (stderr):</b>
       Error: Error { message: "invalid number at line 8 column 16" }
       
       Exit 1

<b>     want:</b>
          <empty>

<b>FAIL</b> <b>valid/spec/table-9</b>
<b> </b>    Error: Error { message: "duplicate key: `apple` for key `fruit` at line 8 column 8" }
<b> </b>    
<b> </b>    Exit 1

<b>     input sent to parser-cmd:</b>
       [fruit]
       apple.color = "red"
       apple.taste.sweet = true
       
       # [fruit.apple]  # INVALID
       # [fruit.apple.taste]  # INVALID
       
       [fruit.apple.texture]  # you can add sub-tables
       smooth = true

<b>     output from parser-cmd (stderr):</b>
       Error: Error { message: "duplicate key: `apple` for key `fruit` at line 8 column 8" }
       
       Exit 1

<b>     want:</b>
          <empty>

<b>FAIL</b> <b>valid/table/array-within-dotted</b>
<b> </b>    Error: Error { message: "duplicate key: `apple` for key `fruit` at line 4 column 9" }
<b> </b>    
<b> </b>    Exit 1

<b>     input sent to parser-cmd:</b>
       [fruit]
       apple.color = "red"
       
       [[fruit.apple.seeds]]
       size = 2

<b>     output from parser-cmd (stderr):</b>
       Error: Error { message: "duplicate key: `apple` for key `fruit` at line 4 column 9" }
       
       Exit 1

<b>     want:</b>
          <empty>

toml-test [./scripts/target/release/basic-toml-decoder]: using embedded tests
  valid tests: 138 passed, 19 failed
invalid tests: 279 passed,  4 failed

==> ENCODER TESTS
<b>FAIL</b> <b>valid/array/array</b>
<b> </b>    Error: Error { message: "values must be emitted before tables" }
<b> </b>    
<b> </b>    Exit 1

<b>     input sent to parser-cmd:</b>
       {
         "comments": [
           {
             "type": "integer",
             "value": "1"
           },
           {
             "type": "integer",
             "value": "2"
           }
         ],
         "dates": [
           {
             "type": "datetime",
             "value": "1987-07-05T17:45:00Z"
           },
           {
             "type": "datetime",
             "value": "1979-05-27T07:32:00Z"
           },
           {
             "type": "datetime",
             "value": "2006-06-01T11:00:00Z"
           }
         ],
         "floats": [
           {
             "type": "float",
             "value": "1.1"
           },
           {
             "type": "float",
             "value": "2.1"
           },
           {
             "type": "float",
             "value": "3.1"
           }
         ],
         "ints": [
           {
             "type": "integer",
             "value": "1"
           },
           {
             "type": "integer",
             "value": "2"
           },
           {
             "type": "integer",
             "value": "3"
           }
         ],
         "strings": [
           {
             "type": "string",
             "value": "a"
           },
           {
             "type": "string",
             "value": "b"
           },
           {
             "type": "string",
             "value": "c"
           }
         ]
       }

<b>     output from parser-cmd (stderr):</b>
       Error: Error { message: "values must be emitted before tables" }
       
       Exit 1

<b>     want:</b>
          <empty>

<b>FAIL</b> <b>valid/array/mixed-string-table</b>
<b> </b>    decode TOML from encoder:
<b> </b>      toml: line 2 (last key "contributors"): expected a comma (',') or array terminator (']'), but got '['

<b>     input sent to parser-cmd:</b>
       {
         "contributors": [
           {
             "type": "string",
             "value": "Foo Bar \u003cfoo@example.com\u003e"
           },
           {
             "email": {
               "type": "string",
               "value": "bazqux@example.com"
             },
             "name": {
               "type": "string",
               "value": "Baz Qux"
             },
             "url": {
               "type": "string",
               "value": "https://example.com/bazqux"
             }
           }
         ],
         "mixed": [
           {
             "k": {
               "type": "string",
               "value": "a"
             }
           },
           {
             "type": "string",
             "value": "b"
           },
           {
             "type": "integer",
             "value": "1"
           }
         ]
       }

<b>     output from parser-cmd (stdout):</b>
       contributors = ["Foo Bar <foo@example.com>"
       [[contributors]]
       email = "bazqux@example.com"
       name = "Baz Qux"
       url = "https://example.com/bazqux"
       ]
       
       [[mixed]]
       k = "a"
       , "b", 1

<b>     want:</b>
       contributors = [
         "Foo Bar <foo@example.com>",
         { name = "Baz Qux", email = "bazqux@example.com", url = "https://example.com/bazqux" }
       ]
       
       # Start with a table as the first element. This tests a case that some libraries
       # might have where they will check if the first entry is a table/map/hash/assoc
       # array and then encode it as a table array. This was a reasonable thing to do
       # before TOML 1.0 since arrays could only contain one type, but now it's no
       # longer.
       mixed = [{k="a"}, "b", 1]

<b>FAIL</b> <b>valid/comment/everywhere</b>
<b> </b>    Error: Error { message: "values must be emitted before tables" }
<b> </b>    
<b> </b>    Exit 1

<b>     input sent to parser-cmd:</b>
       {
         "group": {
           "answer": {
             "type": "integer",
             "value": "42"
           },
           "d": {
             "type": "date-local",
             "value": "1979-05-27"
           },
           "dt": {
             "type": "datetime",
             "value": "1979-05-27T07:32:12-07:00"
           },
           "more": [
             {
               "type": "integer",
               "value": "42"
             },
             {
               "type": "integer",
               "value": "42"
             }
           ]
         }
       }

<b>     output from parser-cmd (stderr):</b>
       Error: Error { message: "values must be emitted before tables" }
       
       Exit 1

<b>     want:</b>
          <empty>

<b>FAIL</b> <b>valid/datetime/datetime</b>
<b> </b>    Type for key 'space' differs:
<b> </b>      Expected:     1987-07-05 17:45:00 +0000 UTC (time.Time)
<b> </b>      Your encoder: map[$__toml_private_datetime:1987-07-05T17:45:00Z] (map[string]any)

<b>     input sent to parser-cmd:</b>
       {
         "lower": {
           "type": "datetime",
           "value": "1987-07-05T17:45:00Z"
         },
         "space": {
           "type": "datetime",
           "value": "1987-07-05T17:45:00Z"
         }
       }

<b>     output from parser-cmd (stdout):</b>
       [lower]
       "$__toml_private_datetime" = "1987-07-05T17:45:00Z"
       
       [space]
       "$__toml_private_datetime" = "1987-07-05T17:45:00Z"

<b>     want:</b>
       space = 1987-07-05 17:45:00Z
       lower = 1987-07-05t17:45:00z

<b>FAIL</b> <b>valid/datetime/local</b>
<b> </b>    Type for key 'milli' differs:
<b> </b>      Expected:     1977-12-21 10:32:00.555 +0100 datetime-local (time.Time)
<b> </b>      Your encoder: map[$__toml_private_datetime:1977-12-21T10:32:00.555] (map[string]any)

<b>     input sent to parser-cmd:</b>
       {
         "local": {
           "type": "datetime-local",
           "value": "1987-07-05T17:45:00"
         },
         "milli": {
           "type": "datetime-local",
           "value": "1977-12-21T10:32:00.555"
         },
         "space": {
           "type": "datetime-local",
           "value": "1987-07-05T17:45:00"
         }
       }

<b>     output from parser-cmd (stdout):</b>
       [local]
       "$__toml_private_datetime" = "1987-07-05T17:45:00"
       
       [milli]
       "$__toml_private_datetime" = "1977-12-21T10:32:00.555"
       
       [space]
       "$__toml_private_datetime" = "1987-07-05T17:45:00"

<b>     want:</b>
       local = 1987-07-05T17:45:00
       milli = 1977-12-21T10:32:00.555
       space = 1987-07-05 17:45:00

<b>FAIL</b> <b>valid/datetime/local-date</b>
<b> </b>    Type for key 'bestdayever' differs:
<b> </b>      Expected:     1987-07-05 00:00:00 +0100 date-local (time.Time)
<b> </b>      Your encoder: map[$__toml_private_datetime:1987-07-05] (map[string]any)

<b>     input sent to parser-cmd:</b>
       {
         "bestdayever": {
           "type": "date-local",
           "value": "1987-07-05"
         }
       }

<b>     output from parser-cmd (stdout):</b>
       [bestdayever]
       "$__toml_private_datetime" = "1987-07-05"

<b>     want:</b>
       bestdayever = 1987-07-05

<b>FAIL</b> <b>valid/datetime/local-time</b>
<b> </b>    Type for key 'besttimeever' differs:
<b> </b>      Expected:     0000-01-01 17:45:00 +0100 time-local (time.Time)
<b> </b>      Your encoder: map[$__toml_private_datetime:17:45:00] (map[string]any)

<b>     input sent to parser-cmd:</b>
       {
         "besttimeever": {
           "type": "time-local",
           "value": "17:45:00"
         },
         "milliseconds": {
           "type": "time-local",
           "value": "10:32:00.555"
         }
       }

<b>     output from parser-cmd (stdout):</b>
       [besttimeever]
       "$__toml_private_datetime" = "17:45:00"
       
       [milliseconds]
       "$__toml_private_datetime" = "10:32:00.555"

<b>     want:</b>
       besttimeever = 17:45:00
       milliseconds = 10:32:00.555

<b>FAIL</b> <b>valid/datetime/milliseconds</b>
<b> </b>    Type for key 'utc1' differs:
<b> </b>      Expected:     1987-07-05 17:45:56.123 +0000 UTC (time.Time)
<b> </b>      Your encoder: map[$__toml_private_datetime:1987-07-05T17:45:56.123Z] (map[string]any)

<b>     input sent to parser-cmd:</b>
       {
         "utc1": {
           "type": "datetime",
           "value": "1987-07-05T17:45:56.123Z"
         },
         "utc2": {
           "type": "datetime",
           "value": "1987-07-05T17:45:56.600Z"
         },
         "wita1": {
           "type": "datetime",
           "value": "1987-07-05T17:45:56.123+08:00"
         },
         "wita2": {
           "type": "datetime",
           "value": "1987-07-05T17:45:56.600+08:00"
         }
       }

<b>     output from parser-cmd (stdout):</b>
       [utc1]
       "$__toml_private_datetime" = "1987-07-05T17:45:56.123Z"
       
       [utc2]
       "$__toml_private_datetime" = "1987-07-05T17:45:56.6Z"
       
       [wita1]
       "$__toml_private_datetime" = "1987-07-05T17:45:56.123+08:00"
       
       [wita2]
       "$__toml_private_datetime" = "1987-07-05T17:45:56.6+08:00"

<b>     want:</b>
       utc1  = 1987-07-05T17:45:56.123Z
       utc2  = 1987-07-05T17:45:56.6Z
       wita1 = 1987-07-05T17:45:56.123+08:00
       wita2 = 1987-07-05T17:45:56.6+08:00

<b>FAIL</b> <b>valid/datetime/timezone</b>
<b> </b>    Type for key 'utc' differs:
<b> </b>      Expected:     1987-07-05 17:45:56 +0000 UTC (time.Time)
<b> </b>      Your encoder: map[$__toml_private_datetime:1987-07-05T17:45:56Z] (map[string]any)

<b>     input sent to parser-cmd:</b>
       {
         "nzdt": {
           "type": "datetime",
           "value": "1987-07-05T17:45:56+13:00"
         },
         "nzst": {
           "type": "datetime",
           "value": "1987-07-05T17:45:56+12:00"
         },
         "pdt": {
           "type": "datetime",
           "value": "1987-07-05T17:45:56-05:00"
         },
         "utc": {
           "type": "datetime",
           "value": "1987-07-05T17:45:56Z"
         }
       }

<b>     output from parser-cmd (stdout):</b>
       [nzdt]
       "$__toml_private_datetime" = "1987-07-05T17:45:56+13:00"
       
       [nzst]
       "$__toml_private_datetime" = "1987-07-05T17:45:56+12:00"
       
       [pdt]
       "$__toml_private_datetime" = "1987-07-05T17:45:56-05:00"
       
       [utc]
       "$__toml_private_datetime" = "1987-07-05T17:45:56Z"

<b>     want:</b>
       utc  = 1987-07-05T17:45:56Z
       pdt  = 1987-07-05T17:45:56-05:00
       nzst = 1987-07-05T17:45:56+12:00
       nzdt = 1987-07-05T17:45:56+13:00  # DST

<b>FAIL</b> <b>valid/example</b>
<b> </b>    Type for key 'best-day-ever' differs:
<b> </b>      Expected:     1987-07-05 17:45:00 +0000 UTC (time.Time)
<b> </b>      Your encoder: map[$__toml_private_datetime:1987-07-05T17:45:00Z] (map[string]any)

<b>     input sent to parser-cmd:</b>
       {
         "best-day-ever": {
           "type": "datetime",
           "value": "1987-07-05T17:45:00Z"
         },
         "numtheory": {
           "boring": {
             "type": "bool",
             "value": "false"
           },
           "perfection": [
             {
               "type": "integer",
               "value": "6"
             },
             {
               "type": "integer",
               "value": "28"
             },
             {
               "type": "integer",
               "value": "496"
             }
           ]
         }
       }

<b>     output from parser-cmd (stdout):</b>
       [best-day-ever]
       "$__toml_private_datetime" = "1987-07-05T17:45:00Z"
       
       [numtheory]
       boring = false
       perfection = [6, 28, 496]

<b>     want:</b>
       best-day-ever = 1987-07-05T17:45:00Z
       
       [numtheory]
       boring = false
       perfection = [6, 28, 496]

<b>FAIL</b> <b>valid/inline-table/nest</b>
<b> </b>    decode TOML from encoder:
<b> </b>      toml: line 2 (last key "arr_arr_tbl_empty"): expected '.' or '=', but got ']' instead

<b>     input sent to parser-cmd:</b>
       {
         "arr_arr_tbl_empty": [
           [
             {}
           ]
         ],
         "arr_arr_tbl_val": [
           [
             {
               "one": {
                 "type": "integer",
                 "value": "1"
               }
             }
           ]
         ],
         "arr_arr_tbls": [
           [
             {
               "one": {
                 "type": "integer",
                 "value": "1"
               }
             },
             {
               "two": {
                 "type": "integer",
                 "value": "2"
               }
             }
           ]
         ],
         "arr_tbl_tbl": [
           {
             "tbl": {
               "one": {
                 "type": "integer",
                 "value": "1"
               }
             }
           }
         ],
         "tbl_arr_tbl": {
           "arr_tbl": [
             {
               "one": {
                 "type": "integer",
                 "value": "1"
               }
             }
           ]
         },
         "tbl_tbl_empty": {
           "tbl_0": {}
         },
         "tbl_tbl_val": {
           "tbl_1": {
             "one": {
               "type": "integer",
               "value": "1"
             }
           }
         }
       }

<b>     output from parser-cmd (stdout):</b>
       [[arr_arr_tbl_empty]]
       ]
       [[arr_arr_tbl_val]]
       one = 1
       ]
       [[arr_arr_tbls]]
       one = 1
       
       [[arr_arr_tbls]]
       two = 2
       ]
       
       [[arr_tbl_tbl]]
       [arr_tbl_tbl.tbl]
       one = 1
       [[tbl_arr_tbl.arr_tbl]]
       one = 1
       [tbl_tbl_empty.tbl_0]
       [tbl_tbl_val.tbl_1]
       one = 1

<b>     want:</b>
       tbl_tbl_empty = { tbl_0 = {} }
       tbl_tbl_val   = { tbl_1 = { one = 1 } }
       tbl_arr_tbl   = { arr_tbl = [ { one = 1 } ] }
       arr_tbl_tbl   = [ { tbl = { one = 1 } } ]
       
       # Array-of-array-of-table is interesting because it can only
       # be represented in inline form.
       arr_arr_tbl_empty = [ [ {} ] ]
       arr_arr_tbl_val = [ [ { one = 1 } ] ]
       arr_arr_tbls  = [ [ { one = 1 }, { two = 2 } ] ]

<b>FAIL</b> <b>valid/key/alphanum</b>
<b> </b>    Error: Error { message: "values must be emitted before tables" }
<b> </b>    
<b> </b>    Exit 1

<b>     input sent to parser-cmd:</b>
       {
         "000111": {
           "type": "string",
           "value": "leading"
         },
         "10e3": {
           "type": "string",
           "value": "false float"
         },
         "123": {
           "type": "string",
           "value": "num"
         },
         "2018_10": {
           "001": {
             "type": "integer",
             "value": "1"
           }
         },
         "34-11": {
           "type": "integer",
           "value": "23"
         },
         "a-a-a": {
           "_": {
             "type": "bool",
             "value": "false"
           }
         },
         "alpha": {
           "type": "string",
           "value": "a"
         },
         "one1two2": {
           "type": "string",
           "value": "mixed"
         },
         "under_score": {
           "type": "string",
           "value": "___"
         },
         "with-dash": {
           "type": "string",
           "value": "dashed"
         }
       }

<b>     output from parser-cmd (stderr):</b>
       Error: Error { message: "values must be emitted before tables" }
       
       Exit 1

<b>     want:</b>
          <empty>

<b>FAIL</b> <b>valid/key/case-sensitive</b>
<b> </b>    Error: Error { message: "values must be emitted before tables" }
<b> </b>    
<b> </b>    Exit 1

<b>     input sent to parser-cmd:</b>
       {
         "Section": {
           "M": {
             "type": "string",
             "value": "latin letter M"
           },
           "name": {
             "type": "string",
             "value": "different section!!"
           },
           "Μ": {
             "type": "string",
             "value": "greek capital letter MU"
           },
           "μ": {
             "type": "string",
             "value": "greek small letter mu"
           }
         },
         "sectioN": {
           "type": "string",
           "value": "NN"
         },
         "section": {
           "NAME": {
             "type": "string",
             "value": "upper"
           },
           "Name": {
             "type": "string",
             "value": "capitalized"
           },
           "name": {
             "type": "string",
             "value": "lower"
           }
         }
       }

<b>     output from parser-cmd (stderr):</b>
       Error: Error { message: "values must be emitted before tables" }
       
       Exit 1

<b>     want:</b>
          <empty>

<b>FAIL</b> <b>valid/key/escapes</b>
<b> </b>    Error: Error { message: "values must be emitted before tables" }
<b> </b>    
<b> </b>    Exit 1

<b>     input sent to parser-cmd:</b>
       {
         "\n": {
           "type": "string",
           "value": "newline"
         },
         "\"": {
           "type": "string",
           "value": "just a quote"
         },
         "\"quoted\"": {
           "quote": {
             "type": "bool",
             "value": "true"
           }
         },
         "a.b": {
           "À": {}
         },
         "backsp\u0008\u0008": {},
         "À": {
           "type": "string",
           "value": "latin capital letter A with grave"
         }
       }

<b>     output from parser-cmd (stderr):</b>
       Error: Error { message: "values must be emitted before tables" }
       
       Exit 1

<b>     want:</b>
          <empty>

<b>FAIL</b> <b>valid/key/quoted-dots</b>
<b> </b>    Error: Error { message: "values must be emitted before tables" }
<b> </b>    
<b> </b>    Exit 1

<b>     input sent to parser-cmd:</b>
       {
         "plain": {
           "type": "integer",
           "value": "1"
         },
         "plain_table": {
           "plain": {
             "type": "integer",
             "value": "3"
           },
           "with.dot": {
             "type": "integer",
             "value": "4"
           }
         },
         "table": {
           "withdot": {
             "key.with.dots": {
               "type": "integer",
               "value": "6"
             },
             "plain": {
               "type": "integer",
               "value": "5"
             }
           }
         },
         "with.dot": {
           "type": "integer",
           "value": "2"
         }
       }

<b>     output from parser-cmd (stderr):</b>
       Error: Error { message: "values must be emitted before tables" }
       
       Exit 1

<b>     want:</b>
          <empty>

<b>FAIL</b> <b>valid/key/space</b>
<b> </b>    Error: Error { message: "values must be emitted before tables" }
<b> </b>    
<b> </b>    Exit 1

<b>     input sent to parser-cmd:</b>
       {
         " c d ": {
           "type": "integer",
           "value": "2"
         },
         " tbl ": {
           "\ttab\ttab\t": {
             "type": "string",
             "value": "tab"
           }
         },
         "a b": {
           "type": "integer",
           "value": "1"
         }
       }

<b>     output from parser-cmd (stderr):</b>
       Error: Error { message: "values must be emitted before tables" }
       
       Exit 1

<b>     want:</b>
          <empty>

<b>FAIL</b> <b>valid/spec-example-1</b>
<b> </b>    Error: Error { message: "values must be emitted before tables" }
<b> </b>    
<b> </b>    Exit 1

<b>     input sent to parser-cmd:</b>
       {
         "clients": {
           "data": [
             [
               {
                 "type": "string",
                 "value": "gamma"
               },
               {
                 "type": "string",
                 "value": "delta"
               }
             ],
             [
               {
                 "type": "integer",
                 "value": "1"
               },
               {
                 "type": "integer",
                 "value": "2"
               }
             ]
           ],
           "hosts": [
             {
               "type": "string",
               "value": "alpha"
             },
             {
               "type": "string",
               "value": "omega"
             }
           ]
         },
         "database": {
           "connection_max": {
             "type": "integer",
             "value": "5000"
           },
           "enabled": {
             "type": "bool",
             "value": "true"
           },
           "ports": [
             {
               "type": "integer",
               "value": "8001"
             },
             {
               "type": "integer",
               "value": "8001"
             },
             {
               "type": "integer",
               "value": "8002"
             }
           ],
           "server": {
             "type": "string",
             "value": "192.168.1.1"
           }
         },
         "owner": {
           "dob": {
             "type": "datetime",
             "value": "1979-05-27T07:32:00-08:00"
           },
           "name": {
             "type": "string",
             "value": "Lance Uppercut"
           }
         },
         "servers": {
           "alpha": {
             "dc": {
               "type": "string",
               "value": "eqdc10"
             },
             "ip": {
               "type": "string",
               "value": "10.0.0.1"
             }
           },
           "beta": {
             "dc": {
               "type": "string",
               "value": "eqdc10"
             },
             "ip": {
               "type": "string",
               "value": "10.0.0.2"
             }
           }
         },
         "title": {
           "type": "string",
           "value": "TOML Example"
         }
       }

<b>     output from parser-cmd (stderr):</b>
       Error: Error { message: "values must be emitted before tables" }
       
       Exit 1

<b>     want:</b>
          <empty>

<b>FAIL</b> <b>valid/spec-example-1-compact</b>
<b> </b>    Error: Error { message: "values must be emitted before tables" }
<b> </b>    
<b> </b>    Exit 1

<b>     input sent to parser-cmd:</b>
       {
         "clients": {
           "data": [
             [
               {
                 "type": "string",
                 "value": "gamma"
               },
               {
                 "type": "string",
                 "value": "delta"
               }
             ],
             [
               {
                 "type": "integer",
                 "value": "1"
               },
               {
                 "type": "integer",
                 "value": "2"
               }
             ]
           ],
           "hosts": [
             {
               "type": "string",
               "value": "alpha"
             },
             {
               "type": "string",
               "value": "omega"
             }
           ]
         },
         "database": {
           "connection_max": {
             "type": "integer",
             "value": "5000"
           },
           "enabled": {
             "type": "bool",
             "value": "true"
           },
           "ports": [
             {
               "type": "integer",
               "value": "8001"
             },
             {
               "type": "integer",
               "value": "8001"
             },
             {
               "type": "integer",
               "value": "8002"
             }
           ],
           "server": {
             "type": "string",
             "value": "192.168.1.1"
           }
         },
         "owner": {
           "dob": {
             "type": "datetime",
             "value": "1979-05-27T07:32:00-08:00"
           },
           "name": {
             "type": "string",
             "value": "Lance Uppercut"
           }
         },
         "servers": {
           "alpha": {
             "dc": {
               "type": "string",
               "value": "eqdc10"
             },
             "ip": {
               "type": "string",
               "value": "10.0.0.1"
             }
           },
           "beta": {
             "dc": {
               "type": "string",
               "value": "eqdc10"
             },
             "ip": {
               "type": "string",
               "value": "10.0.0.2"
             }
           }
         },
         "title": {
           "type": "string",
           "value": "TOML Example"
         }
       }

<b>     output from parser-cmd (stderr):</b>
       Error: Error { message: "values must be emitted before tables" }
       
       Exit 1

<b>     want:</b>
          <empty>

<b>FAIL</b> <b>valid/spec/array-0</b>
<b> </b>    Error: Error { message: "values must be emitted before tables" }
<b> </b>    
<b> </b>    Exit 1

<b>     input sent to parser-cmd:</b>
       {
         "colors": [
           {
             "type": "string",
             "value": "red"
           },
           {
             "type": "string",
             "value": "yellow"
           },
           {
             "type": "string",
             "value": "green"
           }
         ],
         "contributors": [
           {
             "type": "string",
             "value": "Foo Bar \u003cfoo@example.com\u003e"
           },
           {
             "email": {
               "type": "string",
               "value": "bazqux@example.com"
             },
             "name": {
               "type": "string",
               "value": "Baz Qux"
             },
             "url": {
               "type": "string",
               "value": "https://example.com/bazqux"
             }
           }
         ],
         "integers": [
           {
             "type": "integer",
             "value": "1"
           },
           {
             "type": "integer",
             "value": "2"
           },
           {
             "type": "integer",
             "value": "3"
           }
         ],
         "nested_arrays_of_ints": [
           [
             {
               "type": "integer",
               "value": "1"
             },
             {
               "type": "integer",
               "value": "2"
             }
           ],
           [
             {
               "type": "integer",
               "value": "3"
             },
             {
               "type": "integer",
               "value": "4"
             },
             {
               "type": "integer",
               "value": "5"
             }
           ]
         ],
         "nested_mixed_array": [
           [
             {
               "type": "integer",
               "value": "1"
             },
             {
               "type": "integer",
               "value": "2"
             }
           ],
           [
             {
               "type": "string",
               "value": "a"
             },
             {
               "type": "string",
               "value": "b"
             },
             {
               "type": "string",
               "value": "c"
             }
           ]
         ],
         "numbers": [
           {
             "type": "float",
             "value": "0.1"
           },
           {
             "type": "float",
             "value": "0.2"
           },
           {
             "type": "float",
             "value": "0.5"
           },
           {
             "type": "integer",
             "value": "1"
           },
           {
             "type": "integer",
             "value": "2"
           },
           {
             "type": "integer",
             "value": "5"
           }
         ],
         "string_array": [
           {
             "type": "string",
             "value": "all"
           },
           {
             "type": "string",
             "value": "strings"
           },
           {
             "type": "string",
             "value": "are the same"
           },
           {
             "type": "string",
             "value": "type"
           }
         ]
       }

<b>     output from parser-cmd (stderr):</b>
       Error: Error { message: "values must be emitted before tables" }
       
       Exit 1

<b>     want:</b>
          <empty>

<b>FAIL</b> <b>valid/spec/local-date-0</b>
<b> </b>    Type for key 'ld1' differs:
<b> </b>      Expected:     1979-05-27 00:00:00 +0100 date-local (time.Time)
<b> </b>      Your encoder: map[$__toml_private_datetime:1979-05-27] (map[string]any)

<b>     input sent to parser-cmd:</b>
       {
         "ld1": {
           "type": "date-local",
           "value": "1979-05-27"
         }
       }

<b>     output from parser-cmd (stdout):</b>
       [ld1]
       "$__toml_private_datetime" = "1979-05-27"

<b>     want:</b>
       ld1 = 1979-05-27

<b>FAIL</b> <b>valid/spec/local-date-time-0</b>
<b> </b>    Type for key 'ldt1' differs:
<b> </b>      Expected:     1979-05-27 07:32:00 +0100 datetime-local (time.Time)
<b> </b>      Your encoder: map[$__toml_private_datetime:1979-05-27T07:32:00] (map[string]any)

<b>     input sent to parser-cmd:</b>
       {
         "ldt1": {
           "type": "datetime-local",
           "value": "1979-05-27T07:32:00"
         },
         "ldt2": {
           "type": "datetime-local",
           "value": "1979-05-27T00:32:00.999999"
         }
       }

<b>     output from parser-cmd (stdout):</b>
       [ldt1]
       "$__toml_private_datetime" = "1979-05-27T07:32:00"
       
       [ldt2]
       "$__toml_private_datetime" = "1979-05-27T00:32:00.999999"

<b>     want:</b>
       ldt1 = 1979-05-27T07:32:00
       ldt2 = 1979-05-27T00:32:00.999999

<b>FAIL</b> <b>valid/spec/local-time-0</b>
<b> </b>    Type for key 'lt1' differs:
<b> </b>      Expected:     0000-01-01 07:32:00 +0100 time-local (time.Time)
<b> </b>      Your encoder: map[$__toml_private_datetime:07:32:00] (map[string]any)

<b>     input sent to parser-cmd:</b>
       {
         "lt1": {
           "type": "time-local",
           "value": "07:32:00"
         },
         "lt2": {
           "type": "time-local",
           "value": "00:32:00.999999"
         }
       }

<b>     output from parser-cmd (stdout):</b>
       [lt1]
       "$__toml_private_datetime" = "07:32:00"
       
       [lt2]
       "$__toml_private_datetime" = "00:32:00.999999"

<b>     want:</b>
       lt1 = 07:32:00
       lt2 = 00:32:00.999999

<b>FAIL</b> <b>valid/spec/offset-date-time-0</b>
<b> </b>    Type for key 'odt1' differs:
<b> </b>      Expected:     1979-05-27 07:32:00 +0000 UTC (time.Time)
<b> </b>      Your encoder: map[$__toml_private_datetime:1979-05-27T07:32:00Z] (map[string]any)

<b>     input sent to parser-cmd:</b>
       {
         "odt1": {
           "type": "datetime",
           "value": "1979-05-27T07:32:00Z"
         },
         "odt2": {
           "type": "datetime",
           "value": "1979-05-27T00:32:00-07:00"
         },
         "odt3": {
           "type": "datetime",
           "value": "1979-05-27T00:32:00.999999-07:00"
         }
       }

<b>     output from parser-cmd (stdout):</b>
       [odt1]
       "$__toml_private_datetime" = "1979-05-27T07:32:00Z"
       
       [odt2]
       "$__toml_private_datetime" = "1979-05-27T00:32:00-07:00"
       
       [odt3]
       "$__toml_private_datetime" = "1979-05-27T00:32:00.999999-07:00"

<b>     want:</b>
       odt1 = 1979-05-27T07:32:00Z
       odt2 = 1979-05-27T00:32:00-07:00
       odt3 = 1979-05-27T00:32:00.999999-07:00

<b>FAIL</b> <b>valid/spec/offset-date-time-1</b>
<b> </b>    Type for key 'odt4' differs:
<b> </b>      Expected:     1979-05-27 07:32:00 +0000 UTC (time.Time)
<b> </b>      Your encoder: map[$__toml_private_datetime:1979-05-27T07:32:00Z] (map[string]any)

<b>     input sent to parser-cmd:</b>
       {
         "odt4": {
           "type": "datetime",
           "value": "1979-05-27T07:32:00Z"
         }
       }

<b>     output from parser-cmd (stdout):</b>
       [odt4]
       "$__toml_private_datetime" = "1979-05-27T07:32:00Z"

<b>     want:</b>
       odt4 = 1979-05-27 07:32:00Z

<b>FAIL</b> <b>valid/spec/table-7</b>
<b> </b>    Error: Error { message: "values must be emitted before tables" }
<b> </b>    
<b> </b>    Exit 1

<b>     input sent to parser-cmd:</b>
       {
         "breed": {
           "type": "string",
           "value": "pug"
         },
         "name": {
           "type": "string",
           "value": "Fido"
         },
         "owner": {
           "member_since": {
             "type": "date-local",
             "value": "1999-08-04"
           },
           "name": {
             "type": "string",
             "value": "Regina Dogman"
           }
         }
       }

<b>     output from parser-cmd (stderr):</b>
       Error: Error { message: "values must be emitted before tables" }
       
       Exit 1

<b>     want:</b>
          <empty>

toml-test [./scripts/target/release/basic-toml-encoder]: using embedded tests
encoder tests: 132 passed, 25 failed
took 0.12 (error) (error)
</pre>
