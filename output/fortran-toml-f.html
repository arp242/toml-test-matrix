<pre>
f4f1cc7
<b>FAIL</b> <b>valid/key/escapes</b>
<b> </b>    error: Invalid character in key
<b> </b>     --> stdin:1:1-4
<b> </b>      |
<b> </b>    1 | "\n" = "newline"
<b> </b>      | ^^^^ key cannot contain newline
<b> </b>      |
<b> </b>    ERROR STOP 
<b> </b>    
<b> </b>    Error termination. Backtrace:
<b> </b>    #0  0x‚Ä¶ in ???
<b> </b>    #1  0x‚Ä¶ in ???
<b> </b>    #2  0x‚Ä¶ in ???
<b> </b>    #3  0x‚Ä¶ in toml2json
<b> </b>    	at ../test/compliance/toml2json.f90:63
<b> </b>    #4  0x‚Ä¶ in main
<b> </b>    	at ../test/compliance/toml2json.f90:17
<b> </b>    
<b> </b>    Exit 1

<b>     input sent to parser-cmd:</b>
       "\n" = "newline"
       "\b" = "bell"
       "\u00c0" = "latin capital letter A with grave"
       "\"" = "just a quote"
       
       ["backsp\b\b"]
       
       ["\"quoted\""]
       quote = true
       
       ["a.b"."\u00c0"]

<b>     output from parser-cmd (stderr):</b>
       error: Invalid character in key
        --> stdin:1:1-4
         |
       1 | "\n" = "newline"
         | ^^^^ key cannot contain newline
         |
       ERROR STOP 
       
       Error termination. Backtrace:
       #0  0x‚Ä¶ in ???
       #1  0x‚Ä¶ in ???
       #2  0x‚Ä¶ in ???
       #3  0x‚Ä¶ in toml2json
       	at ../test/compliance/toml2json.f90:63
       #4  0x‚Ä¶ in main
       	at ../test/compliance/toml2json.f90:17
       
       Exit 1

<b>     want:</b>
          <empty>

<b>FAIL</b> <b>valid/key/quoted-unicode</b>
<b> </b>    error: Invalid syntax
<b> </b>     --> stdin:2:1-8
<b> </b>      |
<b> </b>    2 | "\u0000" = "null"
<b> </b>      | ^^^^^^^^ unexpected invalid sequence
<b> </b>      |
<b> </b>    ERROR STOP 
<b> </b>    
<b> </b>    Error termination. Backtrace:
<b> </b>    #0  0x‚Ä¶ in ???
<b> </b>    #1  0x‚Ä¶ in ???
<b> </b>    #2  0x‚Ä¶ in ???
<b> </b>    #3  0x‚Ä¶ in toml2json
<b> </b>    	at ../test/compliance/toml2json.f90:63
<b> </b>    #4  0x‚Ä¶ in main
<b> </b>    	at ../test/compliance/toml2json.f90:17
<b> </b>    
<b> </b>    Exit 1

<b>     input sent to parser-cmd:</b>
       
       "\u0000" = "null"
       '\u0000' = "different key"
       "\u0008 \u000c \U00000041 \u007f \u0080 \u00ff \ud7ff \ue000 \uffff \U00010000 \U0010ffff" = "escaped key"
       
       "~ ¬Ä √ø Ìüø ÓÄÄ Ôøø êÄÄ Ùèøø" = "basic key"
       'l ~ ¬Ä √ø Ìüø ÓÄÄ Ôøø êÄÄ Ùèøø' = "literal key"

<b>     output from parser-cmd (stderr):</b>
       error: Invalid syntax
        --> stdin:2:1-8
         |
       2 | "\u0000" = "null"
         | ^^^^^^^^ unexpected invalid sequence
         |
       ERROR STOP 
       
       Error termination. Backtrace:
       #0  0x‚Ä¶ in ???
       #1  0x‚Ä¶ in ???
       #2  0x‚Ä¶ in ???
       #3  0x‚Ä¶ in toml2json
       	at ../test/compliance/toml2json.f90:63
       #4  0x‚Ä¶ in main
       	at ../test/compliance/toml2json.f90:17
       
       Exit 1

<b>     want:</b>
          <empty>

<b>FAIL</b> <b>valid/spec/string-0</b>
<b> </b>    Values for key "str" don't match:
<b> </b>      Expected:     I'm a string. "You can quote me". Name	Jos√©
<b> </b>    Location	SF.
<b> </b>      Your encoder: I'm a string. "You can quote me". Name	Jos√©nLocation	SF.

<b>     input sent to parser-cmd:</b>
       str = "I'm a string. \"You can quote me\". Name\tJos\u00E9\nLocation\tSF."

<b>     output from parser-cmd (stdout):</b>
       {
         "str": {
           "type": "string",
           "value": "I'm a string. \"You can quote me\". Name\tJos√©nLocation\tSF."
         }
       }

<b>     want:</b>
       {
         "str": {
           "type": "string",
           "value": "I'm a string. \"You can quote me\". Name\tJos√©\nLocation\tSF."
         }
       }

<b>FAIL</b> <b>valid/spec/string-3</b>
<b> </b>    Values for key "str2" don't match:
<b> </b>      Expected:     The quick brown fox jumps over the lazy dog.
<b> </b>      Your encoder: The quick brown 
<b> </b>    
<b> </b>      fox jumps over     the lazy dog.

<b>     input sent to parser-cmd:</b>
       # The following strings are byte-for-byte equivalent:
       str1 = "The quick brown fox jumps over the lazy dog."
       
       str2 = """
       The quick brown \
       
       
         fox jumps over \
           the lazy dog."""
       
       str3 = """\
              The quick brown \
              fox jumps over \
              the lazy dog.\
              """

<b>     output from parser-cmd (stdout):</b>
       {
         "str1": {
           "type": "string",
           "value": "The quick brown fox jumps over the lazy dog."
         },
         "str2": {
           "type": "string",
           "value": "The quick brown \n\n  fox jumps over     the lazy dog."
         },
         "str3": {
           "type": "string",
           "value": "       The quick brown        fox jumps over        the lazy dog.       "
         }
       }

<b>     want:</b>
       {
         "str1": {
           "type": "string",
           "value": "The quick brown fox jumps over the lazy dog."
         },
         "str2": {
           "type": "string",
           "value": "The quick brown fox jumps over the lazy dog."
         },
         "str3": {
           "type": "string",
           "value": "The quick brown fox jumps over the lazy dog."
         }
       }

<b>FAIL</b> <b>valid/string/ends-in-whitespace-escape</b>
<b> </b>    Values for key "beee" don't match:
<b> </b>      Expected:     heeee
<b> </b>    geeee
<b> </b>      Your encoder: heeee
<b> </b>    geeee
<b> </b>    
<b> </b>          

<b>     input sent to parser-cmd:</b>
       beee = """
       heeee
       geeee\  
       
       
             """

<b>     output from parser-cmd (stdout):</b>
       {
         "beee": {
           "type": "string",
           "value": "heeee\ngeeee\n\n      "
         }
       }

<b>     want:</b>
       {
         "beee": {
           "type": "string",
           "value": "heeee\ngeeee"
         }
       }

<b>FAIL</b> <b>valid/string/escape-tricky</b>
<b> </b>    error: Invalid expression for value
<b> </b>     --> stdin:4:21-33
<b> </b>      |
<b> </b>    4 | multiline_unicode = """
<b> </b>      |                     ^^^^^^^^^^^^^ unexpected invalid sequence
<b> </b>      |
<b> </b>    ERROR STOP 
<b> </b>    
<b> </b>    Error termination. Backtrace:
<b> </b>    #0  0x‚Ä¶ in ???
<b> </b>    #1  0x‚Ä¶ in ???
<b> </b>    #2  0x‚Ä¶ in ???
<b> </b>    #3  0x‚Ä¶ in toml2json
<b> </b>    	at ../test/compliance/toml2json.f90:63
<b> </b>    #4  0x‚Ä¶ in main
<b> </b>    	at ../test/compliance/toml2json.f90:17
<b> </b>    
<b> </b>    Exit 1

<b>     input sent to parser-cmd:</b>
       end_esc = "String does not end here\" but ends here\\"
       lit_end_esc = 'String ends here\'
       
       multiline_unicode = """
       \u00a0"""
       
       multiline_not_unicode = """
       \\u0041"""
       
       multiline_end_esc = """When will it end? \"""...""\" should be here\""""
       
       lit_multiline_not_unicode = '''
       \u007f'''
       
       lit_multiline_end = '''There is no escape\'''

<b>     output from parser-cmd (stderr):</b>
       error: Invalid expression for value
        --> stdin:4:21-33
         |
       4 | multiline_unicode = """
         |                     ^^^^^^^^^^^^^ unexpected invalid sequence
         |
       ERROR STOP 
       
       Error termination. Backtrace:
       #0  0x‚Ä¶ in ???
       #1  0x‚Ä¶ in ???
       #2  0x‚Ä¶ in ???
       #3  0x‚Ä¶ in toml2json
       	at ../test/compliance/toml2json.f90:63
       #4  0x‚Ä¶ in main
       	at ../test/compliance/toml2json.f90:17
       
       Exit 1

<b>     want:</b>
          <empty>

<b>FAIL</b> <b>valid/string/escapes</b>
<b> </b>    decode JSON output from parser:
<b> </b>      invalid character '\x1f' in string literal

<b>     input sent to parser-cmd:</b>
       backspace = "This string has a \b backspace character."
       tab = "This string has a \t tab character."
       newline = "This string has a \n new line character."
       formfeed = "This string has a \f form feed character."
       carriage = "This string has a \r carriage return character."
       quote = "This string has a \" quote character."
       backslash = "This string has a \\ backslash character."
       notunicode1 = "This string does not have a unicode \\u escape."
       notunicode2 = "This string does not have a unicode \u005Cu escape."
       notunicode3 = "This string does not have a unicode \\u0075 escape."
       notunicode4 = "This string does not have a unicode \\\u0075 escape."
       delete = "This string has a \u007F delete control code."
       unitseparator = "This string has a \u001F unit separator control code."

<b>     output from parser-cmd (stdout):</b>
       {
         "backspace": {"type": "string", "value": "This string has a \b backspace character."},
         "tab": {"type": "string", "value": "This string has a \t tab character."},
         "newline": {"type": "string", "value": "This string has a \n new line character."},
         "formfeed": {"type": "string", "value": "This string has a \f form feed character."},
         "carriage": {"type": "string", "value": "This string has a \r carriage return character."},
         "quote": {"type": "string", "value": "This string has a \" quote character."},
         "backslash": {"type": "string", "value": "This string has a \\ backslash character."},
         "notunicode1": {"type": "string", "value": "This string does not have a unicode \\u escape."},
         "notunicode2": {"type": "string", "value": "This string does not have a unicode \\ escape."},
         "notunicode3": {"type": "string", "value": "This string does not have a unicode \\u0075 escape."},
         "notunicode4": {"type": "string", "value": "This string does not have a unicode \\uescape."},
         "delete": {"type": "string", "value": "This string has a delete control code."},
         "unitseparator": {"type": "string", "value": "This string has a unit separator control code."}
       }

<b>     want:</b>
       {
         "backslash": {
           "type": "string",
           "value": "This string has a \\ backslash character."
         },
         "backspace": {
           "type": "string",
           "value": "This string has a \u0008 backspace character."
         },
         "carriage": {
           "type": "string",
           "value": "This string has a \r carriage return character."
         },
         "delete": {
           "type": "string",
           "value": "This string has a  delete control code."
         },
         "formfeed": {
           "type": "string",
           "value": "This string has a \u000c form feed character."
         },
         "newline": {
           "type": "string",
           "value": "This string has a \n new line character."
         },
         "notunicode1": {
           "type": "string",
           "value": "This string does not have a unicode \\u escape."
         },
         "notunicode2": {
           "type": "string",
           "value": "This string does not have a unicode \\u escape."
         },
         "notunicode3": {
           "type": "string",
           "value": "This string does not have a unicode \\u0075 escape."
         },
         "notunicode4": {
           "type": "string",
           "value": "This string does not have a unicode \\u escape."
         },
         "quote": {
           "type": "string",
           "value": "This string has a \" quote character."
         },
         "tab": {
           "type": "string",
           "value": "This string has a \t tab character."
         },
         "unitseparator": {
           "type": "string",
           "value": "This string has a \u001f unit separator control code."
         }
       }

<b>FAIL</b> <b>valid/string/multiline</b>
<b> </b>    Values for key "equivalent_three" don't match:
<b> </b>      Expected:     The quick brown fox jumps over the lazy dog.
<b> </b>      Your encoder:        The quick brown        fox jumps over        the lazy dog.       

<b>     input sent to parser-cmd:</b>
       # NOTE: this file includes some literal tab characters.
       
       multiline_empty_one = """"""
       
       # A newline immediately following the opening delimiter will be trimmed.
       multiline_empty_two = """
       """
       
       # \ at the end of line trims newlines as well; note that last \ is followed by
       # two spaces, which are ignored.
       multiline_empty_three = """\
           """
       multiline_empty_four = """\
          \
          \  
          """
       
       equivalent_one = "The quick brown fox jumps over the lazy dog."
       equivalent_two = """
       The quick brown \
       
       
         fox jumps over \
           the lazy dog."""
       
       equivalent_three = """\
              The quick brown \
              fox jumps over \
              the lazy dog.\
              """
       
       whitespace-after-bs = """\
              The quick brown \
              fox jumps over \   
              the lazy dog.\	
              """
       
       no-space = """a\
           b"""
       
       # Has tab character.
       keep-ws-before = """a   	\
          b"""
       
       escape-bs-1 = """a \\
       b"""
       
       escape-bs-2 = """a \\\
       b"""
       
       escape-bs-3 = """a \\\\
         b"""

<b>     output from parser-cmd (stdout):</b>
       {
         "equivalent_one": {
           "type": "string",
           "value": "The quick brown fox jumps over the lazy dog."
         },
         "equivalent_three": {
           "type": "string",
           "value": "       The quick brown        fox jumps over        the lazy dog.       "
         },
         "equivalent_two": {
           "type": "string",
           "value": "The quick brown \n\n  fox jumps over     the lazy dog."
         },
         "escape-bs-1": {
           "type": "string",
           "value": "a \\\nb"
         },
         "escape-bs-2": {
           "type": "string",
           "value": "a \\b"
         },
         "escape-bs-3": {
           "type": "string",
           "value": "a \\\\\n  b"
         },
         "keep-ws-before": {
           "type": "string",
           "value": "a   \t   b"
         },
         "multiline_empty_four": {
           "type": "string",
           "value": "         "
         },
         "multiline_empty_one": {
           "type": "string",
           "value": ""
         },
         "multiline_empty_three": {
           "type": "string",
           "value": "    "
         },
         "multiline_empty_two": {
           "type": "string",
           "value": ""
         },
         "no-space": {
           "type": "string",
           "value": "a    b"
         },
         "whitespace-after-bs": {
           "type": "string",
           "value": "       The quick brown        fox jumps over        the lazy dog.       "
         }
       }

<b>     want:</b>
       {
         "equivalent_one": {
           "type": "string",
           "value": "The quick brown fox jumps over the lazy dog."
         },
         "equivalent_three": {
           "type": "string",
           "value": "The quick brown fox jumps over the lazy dog."
         },
         "equivalent_two": {
           "type": "string",
           "value": "The quick brown fox jumps over the lazy dog."
         },
         "escape-bs-1": {
           "type": "string",
           "value": "a \\\nb"
         },
         "escape-bs-2": {
           "type": "string",
           "value": "a \\b"
         },
         "escape-bs-3": {
           "type": "string",
           "value": "a \\\\\n  b"
         },
         "keep-ws-before": {
           "type": "string",
           "value": "a   \tb"
         },
         "multiline_empty_four": {
           "type": "string",
           "value": ""
         },
         "multiline_empty_one": {
           "type": "string",
           "value": ""
         },
         "multiline_empty_three": {
           "type": "string",
           "value": ""
         },
         "multiline_empty_two": {
           "type": "string",
           "value": ""
         },
         "no-space": {
           "type": "string",
           "value": "ab"
         },
         "whitespace-after-bs": {
           "type": "string",
           "value": "The quick brown fox jumps over the lazy dog."
         }
       }

<b>FAIL</b> <b>valid/string/quoted-unicode</b>
<b> </b>    error: Invalid expression for value
<b> </b>     --> stdin:2:18-114
<b> </b>      |
<b> </b>    2 | escaped_string = "\u0000 \u0008 \u000c \U00000041 \u007f \u0080 \u00ff \ud7ff \ue000 \uffff \U00010000 \U0010ffff"
<b> </b>      |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unexpected invalid sequence
<b> </b>      |
<b> </b>    ERROR STOP 
<b> </b>    
<b> </b>    Error termination. Backtrace:
<b> </b>    #0  0x‚Ä¶ in ???
<b> </b>    #1  0x‚Ä¶ in ???
<b> </b>    #2  0x‚Ä¶ in ???
<b> </b>    #3  0x‚Ä¶ in toml2json
<b> </b>    	at ../test/compliance/toml2json.f90:63
<b> </b>    #4  0x‚Ä¶ in main
<b> </b>    	at ../test/compliance/toml2json.f90:17
<b> </b>    
<b> </b>    Exit 1

<b>     input sent to parser-cmd:</b>
       
       escaped_string = "\u0000 \u0008 \u000c \U00000041 \u007f \u0080 \u00ff \ud7ff \ue000 \uffff \U00010000 \U0010ffff"
       not_escaped_string = '\u0000 \u0008 \u000c \U00000041 \u007f \u0080 \u00ff \ud7ff \ue000 \uffff \U00010000 \U0010ffff'
       
       basic_string = "~ ¬Ä √ø Ìüø ÓÄÄ Ôøø êÄÄ Ùèøø"
       literal_string = '~ ¬Ä √ø Ìüø ÓÄÄ Ôøø êÄÄ Ùèøø'

<b>     output from parser-cmd (stderr):</b>
       error: Invalid expression for value
        --> stdin:2:18-114
         |
       2 | escaped_string = "\u0000 \u0008 \u000c \U00000041 \u007f \u0080 \u00ff \ud7ff \ue000 \uffff \U00010000 \U0010ffff"
         |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unexpected invalid sequence
         |
       ERROR STOP 
       
       Error termination. Backtrace:
       #0  0x‚Ä¶ in ???
       #1  0x‚Ä¶ in ???
       #2  0x‚Ä¶ in ???
       #3  0x‚Ä¶ in toml2json
       	at ../test/compliance/toml2json.f90:63
       #4  0x‚Ä¶ in main
       	at ../test/compliance/toml2json.f90:17
       
       Exit 1

<b>     want:</b>
          <empty>

<b>FAIL</b> <b>valid/string/unicode-escape</b>
<b> </b>    error: Invalid expression for value
<b> </b>     --> stdin:6:11-18
<b> </b>      |
<b> </b>    6 | null-1  = "\u0000"
<b> </b>      |           ^^^^^^^^ unexpected invalid sequence
<b> </b>      |
<b> </b>    ERROR STOP 
<b> </b>    
<b> </b>    Error termination. Backtrace:
<b> </b>    #0  0x‚Ä¶ in ???
<b> </b>    #1  0x‚Ä¶ in ???
<b> </b>    #2  0x‚Ä¶ in ???
<b> </b>    #3  0x‚Ä¶ in toml2json
<b> </b>    	at ../test/compliance/toml2json.f90:63
<b> </b>    #4  0x‚Ä¶ in main
<b> </b>    	at ../test/compliance/toml2json.f90:17
<b> </b>    
<b> </b>    Exit 1

<b>     input sent to parser-cmd:</b>
       delta-1 = "\u03B4"
       delta-2 = "\U000003B4"
       a       = "\u0061"
       b       = "\u0062"
       c       = "\U00000063"
       null-1  = "\u0000"
       null-2  = "\U00000000"
       
       ml-delta-1 = """\u03B4"""
       ml-delta-2 = """\U000003B4"""
       ml-a       = """\u0061"""
       ml-b       = """\u0062"""
       ml-c       = """\U00000063"""
       ml-null-1  = """\u0000"""
       ml-null-2  = """\U00000000"""

<b>     output from parser-cmd (stderr):</b>
       error: Invalid expression for value
        --> stdin:6:11-18
         |
       6 | null-1  = "\u0000"
         |           ^^^^^^^^ unexpected invalid sequence
         |
       ERROR STOP 
       
       Error termination. Backtrace:
       #0  0x‚Ä¶ in ???
       #1  0x‚Ä¶ in ???
       #2  0x‚Ä¶ in ???
       #3  0x‚Ä¶ in toml2json
       	at ../test/compliance/toml2json.f90:63
       #4  0x‚Ä¶ in main
       	at ../test/compliance/toml2json.f90:17
       
       Exit 1

<b>     want:</b>
          <empty>

<b>FAIL</b> <b>invalid/array/extend-defined-aot</b>
<b> </b>    signal: segmentation fault

<b>     input sent to parser-cmd:</b>
       [[tab.arr]]
       [tab]
       arr.val1=1

<b>     output from parser-cmd (stderr):</b>
       Program received signal SIGSEGV: Segmentation fault - invalid memory reference.
       
       Backtrace for this error:
       #0  0x‚Ä¶ in ???
       #1  0x‚Ä¶ in ???
       #2  0x‚Ä¶ in ???
       	at ./signal/../sysdeps/unix/sysv/linux/x86_64/libc_sigaction.c:0
       #3  0x‚Ä¶ in parse_keyval
       	at ../src/tomlf/de/parser.f90:440
       #4  0x‚Ä¶ in parse_root
       	at ../src/tomlf/de/parser.f90:134
       #5  0x‚Ä¶ in __tomlf_de_parser_MOD_parse
       	at ../src/tomlf/de/parser.f90:105
       #6  0x‚Ä¶ in __tomlf_de_MOD_toml_load_unit
       	at ../src/tomlf/de.f90:124
       #7  0x‚Ä¶ in toml2json
       	at ../test/compliance/toml2json.f90:55
       #8  0x‚Ä¶ in main
       	at ../test/compliance/toml2json.f90:17

<b>     want:</b>
       Exit code 1

<b>FAIL</b> <b>invalid/array/extending-table</b>
<b> </b>    signal: aborted

<b>     input sent to parser-cmd:</b>
       a = [{ b = 1 }]
       
       # Cannot extend tables within static arrays
       # https://github.com/toml-lang/toml/issues/908
       [a.c]
       foo = 1

<b>     output from parser-cmd (stderr):</b>
       double free or corruption (out)
       
       Program received signal SIGABRT: Process abort signal.
       
       Backtrace for this error:
       #0  0x‚Ä¶ in ???
       #1  0x‚Ä¶ in ???
       #2  0x‚Ä¶ in ???
       	at ./signal/../sysdeps/unix/sysv/linux/x86_64/libc_sigaction.c:0
       #3  0x‚Ä¶ in __pthread_kill_implementation
       	at ./nptl/pthread_kill.c:44
       #4  0x‚Ä¶ in __GI_raise
       	at ../sysdeps/posix/raise.c:26
       #5  0x‚Ä¶ in __GI_abort
       	at ./stdlib/abort.c:79
       #6  0x‚Ä¶ in __libc_message
       	at ../sysdeps/posix/libc_fatal.c:155
       #7  0x‚Ä¶ in malloc_printerr
       	at ./malloc/malloc.c:5660
       #8  0x‚Ä¶ in _int_free
       	at ./malloc/malloc.c:4584
       #9  0x‚Ä¶ in __GI___libc_free
       	at ./malloc/malloc.c:3385
       #10  0x‚Ä¶ in __tomlf_diagnostic_MOD_render_diagnostic
       	at ../src/tomlf/diagnostic.f90:160
       #11  0x‚Ä¶ in make_error
       	at ../src/tomlf/de/parser.f90:748
       #12  0x‚Ä¶ in __tomlf_de_parser_MOD_parse
       	at ../src/tomlf/de/parser.f90:107
       #13  0x‚Ä¶ in __tomlf_de_MOD_toml_load_unit
       	at ../src/tomlf/de.f90:124
       #14  0x‚Ä¶ in toml2json
       	at ../test/compliance/toml2json.f90:55
       #15  0x‚Ä¶ in main
       	at ../test/compliance/toml2json.f90:17

<b>     want:</b>
       Exit code 1

<b>FAIL</b> <b>invalid/control/bare-cr</b>
<b> </b>    Expected an error, but no error was reported.

<b>     input sent to parser-cmd:</b>
       # The following line contains a single carriage return control character
       

<b>     output from parser-cmd (stdout):</b>
       {}

<b>     want:</b>
       Exit code 1

<b>FAIL</b> <b>invalid/control/comment-cr</b>
<b> </b>    Expected an error, but no error was reported.

<b>     input sent to parser-cmd:</b>
       comment-cr   = "Carriage return in comment" # a=1

<b>     output from parser-cmd (stdout):</b>
       {
         "a": {
           "type": "integer",
           "value": "1"
         },
         "comment-cr": {
           "type": "string",
           "value": "Carriage return in comment"
         }
       }

<b>     want:</b>
       Exit code 1

<b>FAIL</b> <b>invalid/control/comment-del</b>
<b> </b>    Expected an error, but no error was reported.

<b>     input sent to parser-cmd:</b>
       comment-del  = "0x7f"   # 

<b>     output from parser-cmd (stdout):</b>
       {
         "comment-del": {
           "type": "string",
           "value": "0x7f"
         }
       }

<b>     want:</b>
       Exit code 1

<b>FAIL</b> <b>invalid/control/comment-ff</b>
<b> </b>    Expected an error, but no error was reported.

<b>     input sent to parser-cmd:</b>
       comment-ff   = "0x7f"   # 

<b>     output from parser-cmd (stdout):</b>
       {
         "comment-ff": {
           "type": "string",
           "value": "0x7f"
         }
       }

<b>     want:</b>
       Exit code 1

<b>FAIL</b> <b>invalid/control/comment-lf</b>
<b> </b>    Expected an error, but no error was reported.

<b>     input sent to parser-cmd:</b>
       comment-lf   = "ctrl-P" # 

<b>     output from parser-cmd (stdout):</b>
       {
         "comment-lf": {
           "type": "string",
           "value": "ctrl-P"
         }
       }

<b>     want:</b>
       Exit code 1

<b>FAIL</b> <b>invalid/control/comment-null</b>
<b> </b>    Expected an error, but no error was reported.

<b>     input sent to parser-cmd:</b>
       comment-null = "null"   #  

<b>     output from parser-cmd (stdout):</b>
       {
         "comment-null": {
           "type": "string",
           "value": "null"
         }
       }

<b>     want:</b>
       Exit code 1

<b>FAIL</b> <b>invalid/control/comment-us</b>
<b> </b>    Expected an error, but no error was reported.

<b>     input sent to parser-cmd:</b>
       comment-us   = "ctrl-_" # 

<b>     output from parser-cmd (stdout):</b>
       {
         "comment-us": {
           "type": "string",
           "value": "ctrl-_"
         }
       }

<b>     want:</b>
       Exit code 1

<b>FAIL</b> <b>invalid/control/multi-cr</b>
<b> </b>    Expected an error, but no error was reported.

<b>     input sent to parser-cmd:</b>
       multi-cr   = """null"""

<b>     output from parser-cmd (stdout):</b>
       {
         "multi-cr": {
           "type": "string",
           "value": "null\n"
         }
       }

<b>     want:</b>
       Exit code 1

<b>FAIL</b> <b>invalid/control/rawmulti-cd</b>
<b> </b>    Expected an error, but no error was reported.

<b>     input sent to parser-cmd:</b>
       rawmulti-cd   = '''null'''

<b>     output from parser-cmd (stdout):</b>
       {
         "rawmulti-cd": {
           "type": "string",
           "value": "null\n"
         }
       }

<b>     want:</b>
       Exit code 1

<b>FAIL</b> <b>invalid/datetime/time-no-leads</b>
<b> </b>    Expected an error, but no error was reported.

<b>     input sent to parser-cmd:</b>
       # Leading 0 is always required.
       d = 2023-10-01T1:32:00Z

<b>     output from parser-cmd (stdout):</b>
       {
         "d": {
           "type": "date-local",
           "value": "2023-10-01"
         }
       }

<b>     want:</b>
       Exit code 1

<b>FAIL</b> <b>invalid/encoding/bad-codepoint</b>
<b> </b>    Expected an error, but no error was reported.

<b>     input sent to parser-cmd:</b>
       # Invalid codepoint U+D800 : Ì†Ä

<b>     output from parser-cmd (stdout):</b>
       {}

<b>     want:</b>
       Exit code 1

<b>FAIL</b> <b>invalid/encoding/bad-utf8-in-comment</b>
<b> </b>    Expected an error, but no error was reported.

<b>     input sent to parser-cmd:</b>
       # √

<b>     output from parser-cmd (stdout):</b>
       {}

<b>     want:</b>
       Exit code 1

<b>FAIL</b> <b>invalid/encoding/bad-utf8-in-multiline</b>
<b> </b>    Expected an error, but no error was reported.

<b>     input sent to parser-cmd:</b>
       # The following line contains an invalid UTF-8 sequence.
       bad = """√"""

<b>     output from parser-cmd (stdout):</b>
       {
         "bad": {
           "type": "string",
           "value": "ÔøΩ"
         }
       }

<b>     want:</b>
       Exit code 1

<b>FAIL</b> <b>invalid/encoding/bad-utf8-in-multiline-literal</b>
<b> </b>    Expected an error, but no error was reported.

<b>     input sent to parser-cmd:</b>
       # The following line contains an invalid UTF-8 sequence.
       bad = '''√'''

<b>     output from parser-cmd (stdout):</b>
       {
         "bad": {
           "type": "string",
           "value": "ÔøΩ"
         }
       }

<b>     want:</b>
       Exit code 1

<b>FAIL</b> <b>invalid/encoding/bad-utf8-in-string</b>
<b> </b>    Expected an error, but no error was reported.

<b>     input sent to parser-cmd:</b>
       # The following line contains an invalid UTF-8 sequence.
       bad = "√"

<b>     output from parser-cmd (stdout):</b>
       {
         "bad": {
           "type": "string",
           "value": "ÔøΩ"
         }
       }

<b>     want:</b>
       Exit code 1

<b>FAIL</b> <b>invalid/encoding/bad-utf8-in-string-literal</b>
<b> </b>    Expected an error, but no error was reported.

<b>     input sent to parser-cmd:</b>
       # The following line contains an invalid UTF-8 sequence.
       bad = '√'

<b>     output from parser-cmd (stdout):</b>
       {
         "bad": {
           "type": "string",
           "value": "ÔøΩ"
         }
       }

<b>     want:</b>
       Exit code 1

<b>FAIL</b> <b>invalid/inline-table/duplicate-key-4</b>
<b> </b>    signal: segmentation fault

<b>     input sent to parser-cmd:</b>
       tbl = { a.b = "a_b", a.b.c = "a_b_c" }

<b>     output from parser-cmd (stderr):</b>
       Program received signal SIGSEGV: Segmentation fault - invalid memory reference.
       
       Backtrace for this error:
       #0  0x‚Ä¶ in ???
       #1  0x‚Ä¶ in ???
       #2  0x‚Ä¶ in ???
       	at ./signal/../sysdeps/unix/sysv/linux/x86_64/libc_sigaction.c:0
       #3  0x‚Ä¶ in parse_keyval
       	at ../src/tomlf/de/parser.f90:440
       #4  0x‚Ä¶ in parse_keyval
       	at ../src/tomlf/de/parser.f90:456
       #5  0x‚Ä¶ in parse_inline_table
       	at ../src/tomlf/de/parser.f90:595
       #6  0x‚Ä¶ in parse_inline_table
       	at ../src/tomlf/de/parser.f90:565
       #7  0x‚Ä¶ in parse_keyval
       	at ../src/tomlf/de/parser.f90:494
       #8  0x‚Ä¶ in parse_root
       	at ../src/tomlf/de/parser.f90:134
       #9  0x‚Ä¶ in __tomlf_de_parser_MOD_parse
       	at ../src/tomlf/de/parser.f90:105
       #10  0x‚Ä¶ in __tomlf_de_MOD_toml_load_unit
       	at ../src/tomlf/de.f90:124
       #11  0x‚Ä¶ in toml2json
       	at ../test/compliance/toml2json.f90:55
       #12  0x‚Ä¶ in main
       	at ../test/compliance/toml2json.f90:17

<b>     want:</b>
       Exit code 1

<b>FAIL</b> <b>invalid/inline-table/overwrite-6</b>
<b> </b>    signal: segmentation fault

<b>     input sent to parser-cmd:</b>
       a = { b = 1, b.c = 2 }

<b>     output from parser-cmd (stderr):</b>
       Program received signal SIGSEGV: Segmentation fault - invalid memory reference.
       
       Backtrace for this error:
       #0  0x‚Ä¶ in ???
       #1  0x‚Ä¶ in ???
       #2  0x‚Ä¶ in ???
       	at ./signal/../sysdeps/unix/sysv/linux/x86_64/libc_sigaction.c:0
       #3  0x‚Ä¶ in parse_keyval
       	at ../src/tomlf/de/parser.f90:440
       #4  0x‚Ä¶ in parse_inline_table
       	at ../src/tomlf/de/parser.f90:595
       #5  0x‚Ä¶ in parse_inline_table
       	at ../src/tomlf/de/parser.f90:565
       #6  0x‚Ä¶ in parse_keyval
       	at ../src/tomlf/de/parser.f90:494
       #7  0x‚Ä¶ in parse_root
       	at ../src/tomlf/de/parser.f90:134
       #8  0x‚Ä¶ in __tomlf_de_parser_MOD_parse
       	at ../src/tomlf/de/parser.f90:105
       #9  0x‚Ä¶ in __tomlf_de_MOD_toml_load_unit
       	at ../src/tomlf/de.f90:124
       #10  0x‚Ä¶ in toml2json
       	at ../test/compliance/toml2json.f90:55
       #11  0x‚Ä¶ in main
       	at ../test/compliance/toml2json.f90:17

<b>     want:</b>
       Exit code 1

<b>FAIL</b> <b>invalid/inline-table/overwrite-7</b>
<b> </b>    signal: segmentation fault

<b>     input sent to parser-cmd:</b>
       tab = { inner.table = [{}], inner.table.val = "bad" }

<b>     output from parser-cmd (stderr):</b>
       Program received signal SIGSEGV: Segmentation fault - invalid memory reference.
       
       Backtrace for this error:
       #0  0x‚Ä¶ in ???
       #1  0x‚Ä¶ in ???
       #2  0x‚Ä¶ in ???
       	at ./signal/../sysdeps/unix/sysv/linux/x86_64/libc_sigaction.c:0
       #3  0x‚Ä¶ in parse_keyval
       	at ../src/tomlf/de/parser.f90:440
       #4  0x‚Ä¶ in parse_keyval
       	at ../src/tomlf/de/parser.f90:456
       #5  0x‚Ä¶ in parse_inline_table
       	at ../src/tomlf/de/parser.f90:595
       #6  0x‚Ä¶ in parse_inline_table
       	at ../src/tomlf/de/parser.f90:565
       #7  0x‚Ä¶ in parse_keyval
       	at ../src/tomlf/de/parser.f90:494
       #8  0x‚Ä¶ in parse_root
       	at ../src/tomlf/de/parser.f90:134
       #9  0x‚Ä¶ in __tomlf_de_parser_MOD_parse
       	at ../src/tomlf/de/parser.f90:105
       #10  0x‚Ä¶ in __tomlf_de_MOD_toml_load_unit
       	at ../src/tomlf/de.f90:124
       #11  0x‚Ä¶ in toml2json
       	at ../test/compliance/toml2json.f90:55
       #12  0x‚Ä¶ in main
       	at ../test/compliance/toml2json.f90:17

<b>     want:</b>
       Exit code 1

<b>FAIL</b> <b>invalid/key/dotted-redefine-table-1</b>
<b> </b>    signal: segmentation fault

<b>     input sent to parser-cmd:</b>
       a = false
       a.b = true

<b>     output from parser-cmd (stderr):</b>
       Program received signal SIGSEGV: Segmentation fault - invalid memory reference.
       
       Backtrace for this error:
       #0  0x‚Ä¶ in ???
       #1  0x‚Ä¶ in ???
       #2  0x‚Ä¶ in ???
       	at ./signal/../sysdeps/unix/sysv/linux/x86_64/libc_sigaction.c:0
       #3  0x‚Ä¶ in parse_keyval
       	at ../src/tomlf/de/parser.f90:440
       #4  0x‚Ä¶ in parse_root
       	at ../src/tomlf/de/parser.f90:134
       #5  0x‚Ä¶ in __tomlf_de_parser_MOD_parse
       	at ../src/tomlf/de/parser.f90:105
       #6  0x‚Ä¶ in __tomlf_de_MOD_toml_load_unit
       	at ../src/tomlf/de.f90:124
       #7  0x‚Ä¶ in toml2json
       	at ../test/compliance/toml2json.f90:55
       #8  0x‚Ä¶ in main
       	at ../test/compliance/toml2json.f90:17

<b>     want:</b>
       Exit code 1

<b>FAIL</b> <b>invalid/key/dotted-redefine-table-2</b>
<b> </b>    signal: segmentation fault

<b>     input sent to parser-cmd:</b>
       # Defined a.b as int
       a.b = 1
       # Tries to access it as table: error
       a.b.c = 2

<b>     output from parser-cmd (stderr):</b>
       Program received signal SIGSEGV: Segmentation fault - invalid memory reference.
       
       Backtrace for this error:
       #0  0x‚Ä¶ in ???
       #1  0x‚Ä¶ in ???
       #2  0x‚Ä¶ in ???
       	at ./signal/../sysdeps/unix/sysv/linux/x86_64/libc_sigaction.c:0
       #3  0x‚Ä¶ in parse_keyval
       	at ../src/tomlf/de/parser.f90:440
       #4  0x‚Ä¶ in parse_keyval
       	at ../src/tomlf/de/parser.f90:456
       #5  0x‚Ä¶ in parse_root
       	at ../src/tomlf/de/parser.f90:134
       #6  0x‚Ä¶ in __tomlf_de_parser_MOD_parse
       	at ../src/tomlf/de/parser.f90:105
       #7  0x‚Ä¶ in __tomlf_de_MOD_toml_load_unit
       	at ../src/tomlf/de.f90:124
       #8  0x‚Ä¶ in toml2json
       	at ../test/compliance/toml2json.f90:55
       #9  0x‚Ä¶ in main
       	at ../test/compliance/toml2json.f90:17

<b>     want:</b>
       Exit code 1

<b>FAIL</b> <b>invalid/local-datetime/hour-over</b>
<b> </b>    Expected an error, but no error was reported.

<b>     input sent to parser-cmd:</b>
       # time-hour       = 2DIGIT  ; 00-23
       d = 2006-01-01T24:00:00

<b>     output from parser-cmd (stdout):</b>
       {
         "d": {"type": "datetime", "value": "2006-01-01 24:00:00
       
       "}
       }

<b>     want:</b>
       Exit code 1

<b>FAIL</b> <b>invalid/local-datetime/minute-over</b>
<b> </b>    Expected an error, but no error was reported.

<b>     input sent to parser-cmd:</b>
       # time-minute     = 2DIGIT  ; 00-59
       d = 2006-01-01T00:60:00

<b>     output from parser-cmd (stdout):</b>
       {
         "d": {"type": "datetime", "value": "2006-01-01 00:60:00
       
       "}
       }

<b>     want:</b>
       Exit code 1

<b>FAIL</b> <b>invalid/local-datetime/second-over</b>
<b> </b>    Expected an error, but no error was reported.

<b>     input sent to parser-cmd:</b>
       # time-second     = 2DIGIT  ; 00-58, 00-59, 00-60 based on leap second
       #                           ; rules
       d = 2006-01-01T00:00:61

<b>     output from parser-cmd (stdout):</b>
       {
         "d": {"type": "datetime", "value": "2006-01-01 00:00:61
       
       "}
       }

<b>     want:</b>
       Exit code 1

<b>FAIL</b> <b>invalid/local-datetime/time-no-leads</b>
<b> </b>    Expected an error, but no error was reported.

<b>     input sent to parser-cmd:</b>
       # Leading 0 is always required.
       d = 2023-10-01T1:32:00Z

<b>     output from parser-cmd (stdout):</b>
       {
         "d": {
           "type": "date-local",
           "value": "2023-10-01"
         }
       }

<b>     want:</b>
       Exit code 1

<b>FAIL</b> <b>invalid/string/basic-out-of-range-unicode-escape-2</b>
<b> </b>    Expected an error, but no error was reported.

<b>     input sent to parser-cmd:</b>
       a = "\U00D80000"

<b>     output from parser-cmd (stdout):</b>
       {
         "a": {
           "type": "string",
           "value": "ÔøΩÔøΩÔøΩÔøΩÔøΩ"
         }
       }

<b>     want:</b>
       Exit code 1

<b>FAIL</b> <b>invalid/string/multiline-bad-escape-4</b>
<b> </b>    command timed out after 1s; increase -timeout if this isn't an infinite loop or pathological behaviour

<b>     input sent to parser-cmd:</b>
       backslash = """\"""

<b>     output from parser-cmd (stdout):</b>
       

<b>     want:</b>
       Exit code 1

<b>FAIL</b> <b>invalid/table/append-to-array-with-dotted-keys</b>
<b> </b>    signal: segmentation fault

<b>     input sent to parser-cmd:</b>
       [[a.b]]
       
       [a]
       b.y = 2

<b>     output from parser-cmd (stderr):</b>
       Program received signal SIGSEGV: Segmentation fault - invalid memory reference.
       
       Backtrace for this error:
       #0  0x‚Ä¶ in ???
       #1  0x‚Ä¶ in ???
       #2  0x‚Ä¶ in ???
       	at ./signal/../sysdeps/unix/sysv/linux/x86_64/libc_sigaction.c:0
       #3  0x‚Ä¶ in parse_keyval
       	at ../src/tomlf/de/parser.f90:440
       #4  0x‚Ä¶ in parse_root
       	at ../src/tomlf/de/parser.f90:134
       #5  0x‚Ä¶ in __tomlf_de_parser_MOD_parse
       	at ../src/tomlf/de/parser.f90:105
       #6  0x‚Ä¶ in __tomlf_de_MOD_toml_load_unit
       	at ../src/tomlf/de.f90:124
       #7  0x‚Ä¶ in toml2json
       	at ../test/compliance/toml2json.f90:55
       #8  0x‚Ä¶ in main
       	at ../test/compliance/toml2json.f90:17

<b>     want:</b>
       Exit code 1

<b>FAIL</b> <b>invalid/table/append-with-dotted-keys-1</b>
<b> </b>    Expected an error, but no error was reported.

<b>     input sent to parser-cmd:</b>
       # First a.b.c defines a table: a.b.c = {z=9}
       #
       # Then we define a.b.c.t = "str" to add a str to the above table, making it:
       #
       #   a.b.c = {z=9, t="..."}
       #
       # While this makes sense, logically, it was decided this is not valid TOML as
       # it's too confusing/convoluted.
       # 
       # See: https://github.com/toml-lang/toml/issues/846
       #      https://github.com/toml-lang/toml/pull/859
       
       [a.b.c]
         z = 9
       
       [a]
         b.c.t = "Using dotted keys to add to [a.b.c] after explicitly defining it above is not allowed"

<b>     output from parser-cmd (stdout):</b>
       {
         "a": {
           "b": {
             "c": {
               "t": {
                 "type": "string",
                 "value": "Using dotted keys to add to [a.b.c] after explicitly defining it above is not allowed"
               },
               "z": {
                 "type": "integer",
                 "value": "9"
               }
             }
           }
         }
       }

<b>     want:</b>
       Exit code 1

<b>FAIL</b> <b>invalid/table/append-with-dotted-keys-2</b>
<b> </b>    Expected an error, but no error was reported.

<b>     input sent to parser-cmd:</b>
       # This is the same issue as in injection-1.toml, except that nests one level
       # deeper. See that file for a more complete description.
       
       [a.b.c.d]
         z = 9
       
       [a]
         b.c.d.k.t = "Using dotted keys to add to [a.b.c.d] after explicitly defining it above is not allowed"

<b>     output from parser-cmd (stdout):</b>
       {
         "a": {
           "b": {
             "c": {
               "d": {
                 "k": {
                   "t": {
                     "type": "string",
                     "value": "Using dotted keys to add to [a.b.c.d] after explicitly defining it above is not allowed"
                   }
                 },
                 "z": {
                   "type": "integer",
                   "value": "9"
                 }
               }
             }
           }
         }
       }

<b>     want:</b>
       Exit code 1

toml-test v2023-10-13 [./src/fortran-toml-f/_build/test/compliance/toml2json]: using embedded tests
  valid tests: 156 passed, 10 failed
invalid tests: 323 passed, 32 failed

==> ENCODER TESTS
<b>FAIL</b> <b>valid/array/mixed-string-table</b>
<b> </b>    ERROR STOP 
<b> </b>    
<b> </b>    Error termination. Backtrace:
<b> </b>    #0  0x‚Ä¶ in ???
<b> </b>    #1  0x‚Ä¶ in ???
<b> </b>    #2  0x‚Ä¶ in ???
<b> </b>    #3  0x‚Ä¶ in json2toml
<b> </b>    	at ../test/compliance/json2toml.f90:53
<b> </b>    #4  0x‚Ä¶ in main
<b> </b>    	at ../test/compliance/json2toml.f90:17
<b> </b>    
<b> </b>    Exit 1

<b>     input sent to parser-cmd:</b>
       {
         "contributors": [
           {
             "type": "string",
             "value": "Foo Bar \u003cfoo@example.com\u003e"
           },
           {
             "email": {
               "type": "string",
               "value": "bazqux@example.com"
             },
             "name": {
               "type": "string",
               "value": "Baz Qux"
             },
             "url": {
               "type": "string",
               "value": "https://example.com/bazqux"
             }
           }
         ],
         "mixed": [
           {
             "k": {
               "type": "string",
               "value": "a"
             }
           },
           {
             "type": "string",
             "value": "b"
           },
           {
             "type": "integer",
             "value": "1"
           }
         ]
       }

<b>     output from parser-cmd (stderr):</b>
       ERROR STOP 
       
       Error termination. Backtrace:
       #0  0x‚Ä¶ in ???
       #1  0x‚Ä¶ in ???
       #2  0x‚Ä¶ in ???
       #3  0x‚Ä¶ in json2toml
       	at ../test/compliance/json2toml.f90:53
       #4  0x‚Ä¶ in main
       	at ../test/compliance/json2toml.f90:17
       
       Exit 1

<b>     want:</b>
          <empty>

<b>FAIL</b> <b>valid/inline-table/end-in-bool</b>
<b> </b>    ERROR STOP 
<b> </b>    
<b> </b>    Error termination. Backtrace:
<b> </b>    #0  0x‚Ä¶ in ???
<b> </b>    #1  0x‚Ä¶ in ???
<b> </b>    #2  0x‚Ä¶ in ???
<b> </b>    #3  0x‚Ä¶ in json2toml
<b> </b>    	at ../test/compliance/json2toml.f90:53
<b> </b>    #4  0x‚Ä¶ in main
<b> </b>    	at ../test/compliance/json2toml.f90:17
<b> </b>    
<b> </b>    Exit 1

<b>     input sent to parser-cmd:</b>
       {
         "black": {
           "allow_prereleases": {
             "type": "bool",
             "value": "true"
           },
           "python": {
             "type": "string",
             "value": "\u003e3.6"
           },
           "version": {
             "type": "string",
             "value": "\u003e=18.9b0"
           }
         }
       }

<b>     output from parser-cmd (stderr):</b>
       ERROR STOP 
       
       Error termination. Backtrace:
       #0  0x‚Ä¶ in ???
       #1  0x‚Ä¶ in ???
       #2  0x‚Ä¶ in ???
       #3  0x‚Ä¶ in json2toml
       	at ../test/compliance/json2toml.f90:53
       #4  0x‚Ä¶ in main
       	at ../test/compliance/json2toml.f90:17
       
       Exit 1

<b>     want:</b>
          <empty>

<b>FAIL</b> <b>valid/key/escapes</b>
<b> </b>    ERROR STOP 
<b> </b>    
<b> </b>    Error termination. Backtrace:
<b> </b>    #0  0x‚Ä¶ in ???
<b> </b>    #1  0x‚Ä¶ in ???
<b> </b>    #2  0x‚Ä¶ in ???
<b> </b>    #3  0x‚Ä¶ in json2toml
<b> </b>    	at ../test/compliance/json2toml.f90:53
<b> </b>    #4  0x‚Ä¶ in main
<b> </b>    	at ../test/compliance/json2toml.f90:17
<b> </b>    
<b> </b>    Exit 1

<b>     input sent to parser-cmd:</b>
       {
         "\u0008": {
           "type": "string",
           "value": "bell"
         },
         "\n": {
           "type": "string",
           "value": "newline"
         },
         "\"": {
           "type": "string",
           "value": "just a quote"
         },
         "\"quoted\"": {
           "quote": {
             "type": "bool",
             "value": "true"
           }
         },
         "a.b": {
           "√Ä": {}
         },
         "backsp\u0008\u0008": {},
         "√Ä": {
           "type": "string",
           "value": "latin capital letter A with grave"
         }
       }

<b>     output from parser-cmd (stderr):</b>
       ERROR STOP 
       
       Error termination. Backtrace:
       #0  0x‚Ä¶ in ???
       #1  0x‚Ä¶ in ???
       #2  0x‚Ä¶ in ???
       #3  0x‚Ä¶ in json2toml
       	at ../test/compliance/json2toml.f90:53
       #4  0x‚Ä¶ in main
       	at ../test/compliance/json2toml.f90:17
       
       Exit 1

<b>     want:</b>
          <empty>

<b>FAIL</b> <b>valid/key/quoted-unicode</b>
<b> </b>    ERROR STOP 
<b> </b>    
<b> </b>    Error termination. Backtrace:
<b> </b>    #0  0x‚Ä¶ in ???
<b> </b>    #1  0x‚Ä¶ in ???
<b> </b>    #2  0x‚Ä¶ in ???
<b> </b>    #3  0x‚Ä¶ in json2toml
<b> </b>    	at ../test/compliance/json2toml.f90:53
<b> </b>    #4  0x‚Ä¶ in main
<b> </b>    	at ../test/compliance/json2toml.f90:17
<b> </b>    
<b> </b>    Exit 1

<b>     input sent to parser-cmd:</b>
       {
         "\u0000": {
           "type": "string",
           "value": "null"
         },
         "\u0008 \u000c A  ¬Ä √ø Ìüø ÓÄÄ Ôøø êÄÄ Ùèøø": {
           "type": "string",
           "value": "escaped key"
         },
         "\\u0000": {
           "type": "string",
           "value": "different key"
         },
         "l ~ ¬Ä √ø Ìüø ÓÄÄ Ôøø êÄÄ Ùèøø": {
           "type": "string",
           "value": "literal key"
         },
         "~ ¬Ä √ø Ìüø ÓÄÄ Ôøø êÄÄ Ùèøø": {
           "type": "string",
           "value": "basic key"
         }
       }

<b>     output from parser-cmd (stderr):</b>
       ERROR STOP 
       
       Error termination. Backtrace:
       #0  0x‚Ä¶ in ???
       #1  0x‚Ä¶ in ???
       #2  0x‚Ä¶ in ???
       #3  0x‚Ä¶ in json2toml
       	at ../test/compliance/json2toml.f90:53
       #4  0x‚Ä¶ in main
       	at ../test/compliance/json2toml.f90:17
       
       Exit 1

<b>     want:</b>
          <empty>

<b>FAIL</b> <b>valid/key/special-chars</b>
<b> </b>    ERROR STOP 
<b> </b>    
<b> </b>    Error termination. Backtrace:
<b> </b>    #0  0x‚Ä¶ in ???
<b> </b>    #1  0x‚Ä¶ in ???
<b> </b>    #2  0x‚Ä¶ in ???
<b> </b>    #3  0x‚Ä¶ in json2toml
<b> </b>    	at ../test/compliance/json2toml.f90:53
<b> </b>    #4  0x‚Ä¶ in main
<b> </b>    	at ../test/compliance/json2toml.f90:17
<b> </b>    
<b> </b>    Exit 1

<b>     input sent to parser-cmd:</b>
       {
         "=~!@$^\u0026*()_+-`1234567890[]|/?\u003e\u003c.,;:'=": {
           "type": "integer",
           "value": "1"
         }
       }

<b>     output from parser-cmd (stderr):</b>
       ERROR STOP 
       
       Error termination. Backtrace:
       #0  0x‚Ä¶ in ???
       #1  0x‚Ä¶ in ???
       #2  0x‚Ä¶ in ???
       #3  0x‚Ä¶ in json2toml
       	at ../test/compliance/json2toml.f90:53
       #4  0x‚Ä¶ in main
       	at ../test/compliance/json2toml.f90:17
       
       Exit 1

<b>     want:</b>
          <empty>

<b>FAIL</b> <b>valid/spec/array-0</b>
<b> </b>    ERROR STOP 
<b> </b>    
<b> </b>    Error termination. Backtrace:
<b> </b>    #0  0x‚Ä¶ in ???
<b> </b>    #1  0x‚Ä¶ in ???
<b> </b>    #2  0x‚Ä¶ in ???
<b> </b>    #3  0x‚Ä¶ in json2toml
<b> </b>    	at ../test/compliance/json2toml.f90:53
<b> </b>    #4  0x‚Ä¶ in main
<b> </b>    	at ../test/compliance/json2toml.f90:17
<b> </b>    
<b> </b>    Exit 1

<b>     input sent to parser-cmd:</b>
       {
         "colors": [
           {
             "type": "string",
             "value": "red"
           },
           {
             "type": "string",
             "value": "yellow"
           },
           {
             "type": "string",
             "value": "green"
           }
         ],
         "contributors": [
           {
             "type": "string",
             "value": "Foo Bar \u003cfoo@example.com\u003e"
           },
           {
             "email": {
               "type": "string",
               "value": "bazqux@example.com"
             },
             "name": {
               "type": "string",
               "value": "Baz Qux"
             },
             "url": {
               "type": "string",
               "value": "https://example.com/bazqux"
             }
           }
         ],
         "integers": [
           {
             "type": "integer",
             "value": "1"
           },
           {
             "type": "integer",
             "value": "2"
           },
           {
             "type": "integer",
             "value": "3"
           }
         ],
         "nested_arrays_of_ints": [
           [
             {
               "type": "integer",
               "value": "1"
             },
             {
               "type": "integer",
               "value": "2"
             }
           ],
           [
             {
               "type": "integer",
               "value": "3"
             },
             {
               "type": "integer",
               "value": "4"
             },
             {
               "type": "integer",
               "value": "5"
             }
           ]
         ],
         "nested_mixed_array": [
           [
             {
               "type": "integer",
               "value": "1"
             },
             {
               "type": "integer",
               "value": "2"
             }
           ],
           [
             {
               "type": "string",
               "value": "a"
             },
             {
               "type": "string",
               "value": "b"
             },
             {
               "type": "string",
               "value": "c"
             }
           ]
         ],
         "numbers": [
           {
             "type": "float",
             "value": "0.1"
           },
           {
             "type": "float",
             "value": "0.2"
           },
           {
             "type": "float",
             "value": "0.5"
           },
           {
             "type": "integer",
             "value": "1"
           },
           {
             "type": "integer",
             "value": "2"
           },
           {
             "type": "integer",
             "value": "5"
           }
         ],
         "string_array": [
           {
             "type": "string",
             "value": "all"
           },
           {
             "type": "string",
             "value": "strings"
           },
           {
             "type": "string",
             "value": "are the same"
           },
           {
             "type": "string",
             "value": "type"
           }
         ]
       }

<b>     output from parser-cmd (stderr):</b>
       ERROR STOP 
       
       Error termination. Backtrace:
       #0  0x‚Ä¶ in ???
       #1  0x‚Ä¶ in ???
       #2  0x‚Ä¶ in ???
       #3  0x‚Ä¶ in json2toml
       	at ../test/compliance/json2toml.f90:53
       #4  0x‚Ä¶ in main
       	at ../test/compliance/json2toml.f90:17
       
       Exit 1

<b>     want:</b>
          <empty>

<b>FAIL</b> <b>valid/spec/float-0</b>
<b> </b>    Values for key "flt7" differ:
<b> </b>      Expected:     6.626e-34 (float64)
<b> </b>      Your encoder: 0 (float64)

<b>     input sent to parser-cmd:</b>
       {
         "flt1": {
           "type": "float",
           "value": "1"
         },
         "flt2": {
           "type": "float",
           "value": "3.1415"
         },
         "flt3": {
           "type": "float",
           "value": "-0.01"
         },
         "flt4": {
           "type": "float",
           "value": "5e+22"
         },
         "flt5": {
           "type": "float",
           "value": "1e+06"
         },
         "flt6": {
           "type": "float",
           "value": "-0.02"
         },
         "flt7": {
           "type": "float",
           "value": "6.626e-34"
         }
       }

<b>     output from parser-cmd (stdout):</b>
       flt1 = 1.0000000000000000
       flt2 = 3.1415000000000002
       flt3 = -0.0100000000000000
       flt4 = 4.9999999999999996E+22
       flt5 = 1.0000000000000000E+6
       flt6 = -0.0200000000000000
       flt7 = 0.0000000000000000

<b>     want:</b>
       # fractional
       flt1 = +1.0
       flt2 = 3.1415
       flt3 = -0.01
       
       # exponent
       flt4 = 5e+22
       flt5 = 1e06
       flt6 = -2E-2
       
       # both
       flt7 = 6.626e-34

<b>FAIL</b> <b>valid/spec/string-5</b>
<b> </b>    ERROR STOP 
<b> </b>    
<b> </b>    Error termination. Backtrace:
<b> </b>    #0  0x‚Ä¶ in ???
<b> </b>    #1  0x‚Ä¶ in ???
<b> </b>    #2  0x‚Ä¶ in ???
<b> </b>    #3  0x‚Ä¶ in json2toml
<b> </b>    	at ../test/compliance/json2toml.f90:53
<b> </b>    #4  0x‚Ä¶ in main
<b> </b>    	at ../test/compliance/json2toml.f90:17
<b> </b>    
<b> </b>    Exit 1

<b>     input sent to parser-cmd:</b>
       {
         "quoted": {
           "type": "string",
           "value": "Tom \"Dubs\" Preston-Werner"
         },
         "regex": {
           "type": "string",
           "value": "\u003c\\i\\c*\\s*\u003e"
         },
         "winpath": {
           "type": "string",
           "value": "C:\\Users\\nodejs\\templates"
         },
         "winpath2": {
           "type": "string",
           "value": "\\\\ServerX\\admin$\\system32\\"
         }
       }

<b>     output from parser-cmd (stderr):</b>
       ERROR STOP 
       
       Error termination. Backtrace:
       #0  0x‚Ä¶ in ???
       #1  0x‚Ä¶ in ???
       #2  0x‚Ä¶ in ???
       #3  0x‚Ä¶ in json2toml
       	at ../test/compliance/json2toml.f90:53
       #4  0x‚Ä¶ in main
       	at ../test/compliance/json2toml.f90:17
       
       Exit 1

<b>     want:</b>
          <empty>

<b>FAIL</b> <b>valid/string/escapes</b>
<b> </b>    ERROR STOP 
<b> </b>    
<b> </b>    Error termination. Backtrace:
<b> </b>    #0  0x‚Ä¶ in ???
<b> </b>    #1  0x‚Ä¶ in ???
<b> </b>    #2  0x‚Ä¶ in ???
<b> </b>    #3  0x‚Ä¶ in json2toml
<b> </b>    	at ../test/compliance/json2toml.f90:53
<b> </b>    #4  0x‚Ä¶ in main
<b> </b>    	at ../test/compliance/json2toml.f90:17
<b> </b>    
<b> </b>    Exit 1

<b>     input sent to parser-cmd:</b>
       {
         "backslash": {
           "type": "string",
           "value": "This string has a \\ backslash character."
         },
         "backspace": {
           "type": "string",
           "value": "This string has a \u0008 backspace character."
         },
         "carriage": {
           "type": "string",
           "value": "This string has a \r carriage return character."
         },
         "delete": {
           "type": "string",
           "value": "This string has a  delete control code."
         },
         "formfeed": {
           "type": "string",
           "value": "This string has a \u000c form feed character."
         },
         "newline": {
           "type": "string",
           "value": "This string has a \n new line character."
         },
         "notunicode1": {
           "type": "string",
           "value": "This string does not have a unicode \\u escape."
         },
         "notunicode2": {
           "type": "string",
           "value": "This string does not have a unicode \\u escape."
         },
         "notunicode3": {
           "type": "string",
           "value": "This string does not have a unicode \\u0075 escape."
         },
         "notunicode4": {
           "type": "string",
           "value": "This string does not have a unicode \\u escape."
         },
         "quote": {
           "type": "string",
           "value": "This string has a \" quote character."
         },
         "tab": {
           "type": "string",
           "value": "This string has a \t tab character."
         },
         "unitseparator": {
           "type": "string",
           "value": "This string has a \u001f unit separator control code."
         }
       }

<b>     output from parser-cmd (stderr):</b>
       ERROR STOP 
       
       Error termination. Backtrace:
       #0  0x‚Ä¶ in ???
       #1  0x‚Ä¶ in ???
       #2  0x‚Ä¶ in ???
       #3  0x‚Ä¶ in json2toml
       	at ../test/compliance/json2toml.f90:53
       #4  0x‚Ä¶ in main
       	at ../test/compliance/json2toml.f90:17
       
       Exit 1

<b>     want:</b>
          <empty>

<b>FAIL</b> <b>valid/string/quoted-unicode</b>
<b> </b>    ERROR STOP 
<b> </b>    
<b> </b>    Error termination. Backtrace:
<b> </b>    #0  0x‚Ä¶ in ???
<b> </b>    #1  0x‚Ä¶ in ???
<b> </b>    #2  0x‚Ä¶ in ???
<b> </b>    #3  0x‚Ä¶ in json2toml
<b> </b>    	at ../test/compliance/json2toml.f90:53
<b> </b>    #4  0x‚Ä¶ in main
<b> </b>    	at ../test/compliance/json2toml.f90:17
<b> </b>    
<b> </b>    Exit 1

<b>     input sent to parser-cmd:</b>
       {
         "basic_string": {
           "type": "string",
           "value": "~ ¬Ä √ø Ìüø ÓÄÄ Ôøø êÄÄ Ùèøø"
         },
         "escaped_string": {
           "type": "string",
           "value": "\u0000 \u0008 \u000c A  ¬Ä √ø Ìüø ÓÄÄ Ôøø êÄÄ Ùèøø"
         },
         "literal_string": {
           "type": "string",
           "value": "~ ¬Ä √ø Ìüø ÓÄÄ Ôøø êÄÄ Ùèøø"
         },
         "not_escaped_string": {
           "type": "string",
           "value": "\\u0000 \\u0008 \\u000c \\U00000041 \\u007f \\u0080 \\u00ff \\ud7ff \\ue000 \\uffff \\U00010000 \\U0010ffff"
         }
       }

<b>     output from parser-cmd (stderr):</b>
       ERROR STOP 
       
       Error termination. Backtrace:
       #0  0x‚Ä¶ in ???
       #1  0x‚Ä¶ in ???
       #2  0x‚Ä¶ in ???
       #3  0x‚Ä¶ in json2toml
       	at ../test/compliance/json2toml.f90:53
       #4  0x‚Ä¶ in main
       	at ../test/compliance/json2toml.f90:17
       
       Exit 1

<b>     want:</b>
          <empty>

<b>FAIL</b> <b>valid/string/unicode-escape</b>
<b> </b>    ERROR STOP 
<b> </b>    
<b> </b>    Error termination. Backtrace:
<b> </b>    #0  0x‚Ä¶ in ???
<b> </b>    #1  0x‚Ä¶ in ???
<b> </b>    #2  0x‚Ä¶ in ???
<b> </b>    #3  0x‚Ä¶ in json2toml
<b> </b>    	at ../test/compliance/json2toml.f90:53
<b> </b>    #4  0x‚Ä¶ in main
<b> </b>    	at ../test/compliance/json2toml.f90:17
<b> </b>    
<b> </b>    Exit 1

<b>     input sent to parser-cmd:</b>
       {
         "a": {
           "type": "string",
           "value": "a"
         },
         "b": {
           "type": "string",
           "value": "b"
         },
         "c": {
           "type": "string",
           "value": "c"
         },
         "delta-1": {
           "type": "string",
           "value": "Œ¥"
         },
         "delta-2": {
           "type": "string",
           "value": "Œ¥"
         },
         "ml-a": {
           "type": "string",
           "value": "a"
         },
         "ml-b": {
           "type": "string",
           "value": "b"
         },
         "ml-c": {
           "type": "string",
           "value": "c"
         },
         "ml-delta-1": {
           "type": "string",
           "value": "Œ¥"
         },
         "ml-delta-2": {
           "type": "string",
           "value": "Œ¥"
         },
         "ml-null-1": {
           "type": "string",
           "value": "\u0000"
         },
         "ml-null-2": {
           "type": "string",
           "value": "\u0000"
         },
         "null-1": {
           "type": "string",
           "value": "\u0000"
         },
         "null-2": {
           "type": "string",
           "value": "\u0000"
         }
       }

<b>     output from parser-cmd (stderr):</b>
       ERROR STOP 
       
       Error termination. Backtrace:
       #0  0x‚Ä¶ in ???
       #1  0x‚Ä¶ in ???
       #2  0x‚Ä¶ in ???
       #3  0x‚Ä¶ in json2toml
       	at ../test/compliance/json2toml.f90:53
       #4  0x‚Ä¶ in main
       	at ../test/compliance/json2toml.f90:17
       
       Exit 1

<b>     want:</b>
          <empty>

toml-test v2023-10-13 [./src/fortran-toml-f/_build/test/compliance/json2toml]: using embedded tests
encoder tests: 155 passed, 11 failed
took 1.5 158.58
</pre>
